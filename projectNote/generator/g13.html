<div class="ant-card-body"><h1 class="ant-typography" style="font-size: 30px;" data-id="">13. 性能优化</h1><div class="ant-space ant-space-horizontal ant-space-align-center" style="margin-bottom: 15px; gap: 8px;"><div class="ant-space-item" style=""><a class="text-gray-500" target="_blank" href="/user/1601072287388278786">程序员鱼皮</a></div><span class="ant-space-item-split" style=""><div class="ant-divider ant-divider-vertical" role="separator"></div></span><div class="ant-space-item" style=""><span class="text-gray-500">2024-05-16 14:44</span></div><span class="ant-space-item-split" style=""><div class="ant-divider ant-divider-vertical" role="separator"></div></span><div class="ant-space-item"><span class="text-gray-500">阅读 472</span></div></div><div style="margin-bottom: 16px;"></div><div class="course-container"><div class="md-viewer "><div class="markdown-body"><h2 data-id="heading-0">前情回顾</h2>
<p>在上期教程中，我们已经完成了整个在线代码生成平台核心功能的开发，有能力的同学已经可以自行上线项目了。</p>
<p>在企业中，项目上线只是最基础的步骤，在上线后我们会遇到很多 Bug 和问题；而且随着系统用量的不断增长，还会出现很多新的问题。这时，就需要我们根据实际的问题，去进行项目的优化。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.25711274237025505</span></p>
<p>后续的教程中，鱼皮会带大家分析项目中可能存在的问题，并且用多种方式、从不同的角度对项目进行分析优化，让大家学到更多企业开发的实用技能和分析优化思路（比如压力测试）。不再满足于完成，而是尽力把项目做到完美！相信也能给自己的简历增加不少亮点。</p>
<p>本节教程，就让我们从大家最熟悉的性能优化开始吧~</p>
<h2>本节重点<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.14677613745644025</span></h2>
<p>本节教程属于项目的第三阶段 —— 开发在线代码生成器平台。</p>
<p>本节重点内容是性能优化，包括：</p>
<ol>
<li>性能优化思路和通用方法</li>
<li>核心功能性能优化</li>
<li>查询性能优化（7 种方法）<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6227924801321134</span></li>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9354403417184254</span></ol>
<p>注意，虽然本节的性能优化更多的是后端优化，但是优化的思想是所有程序员都需要学习的。</p>
<h2 data-id="heading-2">一、性能优化思路</h2>
<p>在正式对生成器平台项目进行优化前，先给大家分享一些经典的性能优化思路。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8433587141047676</span></p>
<p>首先明确性能优化的定义和目标。性能优化是指通过 <strong>持续的</strong> 分析、实践和测试，确保系统稳定高效运行，从而满足用户的诉求。</p>
<p>性能优化闭环：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/12f048ee-ebea-45ed-be65-7e36fd604a86.png" alt="" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.988476726029234</span></p>
<h3 data-id="heading-3">性能优化分类</h3>
<p>一般情况下，我们把性能优化分为 2 大类：</p>
<p>1）通用优化<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8371431811929315</span></p>
<p>是指一些经典的、对于绝大多数情况都适用的优化策略。比如增大服务器的并发请求处理数、使用缓存减少数据库查询、通过负载均衡分摊请求、同步转异步等。</p>
<p>2）对症下药</p>
<p>是指结合具体的业务特性和系统现状，先通过性能监控工具、压力测试等方式，分析出系统的性能瓶颈，再针对性地选取策略进行优化。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.08090677855505812</span></p>
<p>比如数据库单次查询超过 1 秒，属于慢查询，根据实际的查询条件给对应的字段增加索引，一般就能提高查询性能。</p>
<p>实际开发中，这两类性能优化策略通常都要使用。在系统设计和开发阶段，我们要根据自己的经验，本能地引入一些性能优化的手段，降低后续系统出现问题、需要迭代优化的概率。此外，性能优化一定是持续的，随着需求、用户、系统用量的增多，原本性能符合要求的系统也可能会出现各种新的问题，很难面面俱到、一步到位。</p>
<p>但是，对于复杂的、对可用性和稳定性要求极高的项目，我们可以提前通过压力测试来模拟用户量极大的情况，并提前做好性能优化和应对措施。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.30775923104445635</span></p>
<h3 data-id="heading-4">通用性能优化手段</h3>
<p>有哪些通用的性能优化手段呢？</p>
<p>我们以一个请求的完整生命周期为例，依次去介绍。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7680151010346168</span></p>
<p>通常，用户从发送请求，到最终得到数据，要分别经过以下节点：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/2a3675a6-fe16-4d27-8efe-e66dc598a218.png" alt="" class="medium-zoom-image"></p>
<p>每个节点，我们都有对应的优化方法：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6431864718660405</span></p>
<p>1）前端：</p>
<ul>
<li>离线缓存：利用浏览器的缓存机制，请求过一次的资源就不用重复请求，提高页面加载速度。</li>
<li>请求合并：页面请求过多时，将多个小请求合并成一个大请求，减少网络开销。</li>
<li>懒加载：延迟加载页面的图片等元素，提高首屏加载速度。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6905953665001827</span></li>
</ul>
<p>2）网关：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.25007704850579615</span></p>
<ul>
<li>负载均衡：负责接受请求，根据一定的路由算法转发到对应的后端系统，实现多个后端服务器分摊请求，增大并发量。</li>
<li>缓存：将后端返回的数据进行缓存，下次前端请求时，直接从网关获取数据，减少后端调用、提高数据获取速度。</li>
</ul>
<p>3）后端请求层：</p>
<ul>
<li>服务器优化：根据业务特性，选择性能更高的服务器并调整参数，比如 Nginx、Undertow 等。</li>
<li>微服务：将大型服务拆分为小型服务，并通过微服务网关进行转发，增大各服务的并发处理能力。</li>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5160525389140642</span></ul>
<p>4）业务逻辑层：</p>
<ul>
<li>异步化：将同步的业务逻辑改为异步，尽早响应，提高并发处理能力。</li>
<li>多线程：将复杂的操作拆分成多个任务，通过多线程并发执行，提高任务处理效率。</li>
</ul>
<p>5）中间件（第三方依赖）：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.28462750314102037</span></p>
<ul>
<li>缓存：将数据库查询出的结果数据缓存到性能更高的服务（比如基于内存的 Redis 或本地），减少数据库的压力、并提高数据查询性能。</li>
<li>队列：使用消息队列，对系统进行解耦、或者将操作异步化，实现流量的削峰填谷。</li>
</ul>
<p>6）存储层：</p>
<ul>
<li>分库分表：数据量极大时，对数据库进行垂直或水平切分，提高数据库并发处理能力。</li>
<li>数据清理：定期清理无用或过期的数据，减少存储压力，必要时可以对数据进行备份转储。</li>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7408509782568684</span></ul>
<p>虽然有那么多性能优化方法，但并不是每一种都要用、每一种都有用。在做性能优化时，一定要根据实际情况，权衡性价比和系统改动风险，并且做好充分的测试，不要好心优化、结果给系统导入了新的 Bug。而且一般情况下，不建议大家为了优化盲目引入新技术，先从成本最低的优化方法开始。</p>
<p>举个例子，你在本地使用 Elasticsearch 优化了查询性能，但是公司根本没有成本采购 Elasticsearch，这就脱离了实际情况。</p>
<p>大家先了解这些方法，日后做性能优化时能够想起来就足够了。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0788954353324034</span></p>
<h2 data-id="heading-5">二、核心功能性能优化</h2>
<p>了解基本的性能优化思路和常用的性能优化方法后，我们回到代码生成项目中，优先对项目的核心功能进行性能优化。</p>
<p>先思考，哪些核心功能需要优化？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.41297635442345215</span></p>
<p>那必然是先从耗时较长的功能下手，优化空间会更大一些。</p>
<p>比如：下载生成器、使用生成器、制作生成器。</p>
<p>这些功能主要的耗时都在后端，下面我们依次分析和优化这些功能对应的接口。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9566846533632225</span></p>
<h3 data-id="heading-6">下载生成器接口</h3>
<p>接口名称：downloadGeneratorById</p>
<h4>1、整体测试分析<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.08648235138823468</span></h4>
<p>性能优化时，首先需要测试分析。先不关注接口的细节，直接调用并查看接口的整体耗时，分析是否需要优化。</p>
<p>进入到下载页面，按 F12 打开网络请求控制台，点击 “下载生成器” 测试。</p>
<p>最好多测试几次观察平均时间，如下图：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8251015180491592</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/216cbff5-8a98-48e5-8e9d-e5097a21b851.png" alt="image.png" class="medium-zoom-image"></p>
<p>注意，不同配置的电脑 / 服务器测试结果肯定不同，性能测试要以自己的实际测试情况为主。</p>
<p>我们平台上的代码生成器，一般属于小文件，而视频文件一般属于大文件。对于下载小文件来说，这个时间其实是可以接受的，用户无需等待很久。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.09082708617367818</span></p>
<p>但万一用户上传的生成器是大文件呢？</p>
<p>其实比较好的方法是限制用户上传的文件体积。但如果用户的生成器文件就是很大，怎么办？</p>
<p>这里我们就提前测试一下，应对系统可能出现的问题。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3532344838974577</span></p>
<p>修改 web 项目的 application.yml 配置文件，解除文件上传大小限制：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">yaml</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-yaml hljs" data-highlighted="yes"><span class="hljs-comment"># 文件上传</span>
<span class="hljs-attr">servlet:</span>
  <span class="hljs-attr">multipart:<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.865765496377322</span></span>
    <span class="hljs-comment"># 大小限制</span>
    <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6747115598442406</span></span>
    <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">100MB</span>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7225767195745674</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.230977471009417</span></pre>
<p>测试上传并下载一个 30 多 MB 的文件，发现性能急剧下降，需要等待近 20 秒才会提示用户下载：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8030861302033752</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/7baa7a32-c5a1-48f8-a74c-77762b766bf1.png" alt="image.png" class="medium-zoom-image"></p>
<p>系统用户量不多的情况下，问题倒也不大，但是如果有多个用户同时下载、或者大量用户频繁下载这个文件，服务器的带宽可能会有压力，而且每次下载都会消耗对象存储的流量，都是成本啊！</p>
<p>所以我们必须解决这个问题。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18862370467011336</span></p>
<h4 data-id="heading-8">2、分析代码耗时</h4>
<p>接下来，我们需要通过分析核心代码，统计关键代码的操作耗时，来定位接口的性能瓶颈 —— 即哪一步操作耗时最多。</p>
<p>可以使用 Spring 提供的 <code>StopWatch</code> 计时器工具类，给下载接口添加统计耗时代码：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18766496229381335</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.327058645815814</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();
stopWatch.start();

<span class="hljs-type">COSObject<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.1758636417588333</span></span> <span class="hljs-variable">cosObject</span> <span class="hljs-operator">=</span> cosManager.getObject(filepath);
cosObjectInput = cosObject.getObjectContent();
<span class="hljs-comment">// 处理下载到的流<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5366320572210517</span></span>
<span class="hljs-type">byte</span>[] bytes = IOUtils.toByteArray(cosObjectInput);

stopWatch.stop();
System.out.println(stopWatch.getTotalTimeMillis());
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.34489544033467046</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8052189119075062</span></pre>
<p>通过统计耗时发现，最核心的耗时因素在于 <strong>从第三方对象存储服务下载文件</strong> （这也是我们预料之中的），流程是先下载完整文件到服务器后，再整体写入到响应输出流。</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">// 处理下载到的流，本质上是下载完整文件到服务器</span>
<span class="hljs-type">byte</span>[] bytes = IOUtils.toByteArray(cosObjectInput);
<span class="hljs-comment">// 写入响应输出流<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0948197665278756</span></span>
response.getOutputStream().write(bytes);
response.getOutputStream().flush();
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5849445215545885</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3431495370989972</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.844194809858148</span></pre>
<p>定位到了核心性能瓶颈，接下来如何优化呢？</p>
<h4 data-id="heading-9">3、下载优化 - 遵循最佳实践</h4>
<p>由于是从第三方对象存储服务下载，所以如果需要优化，首先的出发点就是充分了解第三方服务。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9879014774856036</span></p>
<p>对于大厂的服务，一般都有官方文档的最佳实践，建议阅读，而不要自己凭直觉瞎猜。</p>
<p>比如 COS 对象存储的官方文档：<a href="https://cloud.tencent.com/document/product/436/13653">https://cloud.tencent.com/document/product/436/13653</a></p>
<p>在文档中介绍了几种方法，比如使用 CDN 就近下载、调试下载操作相关对象的参数等。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7487254866106356</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/7878e9e4-f791-4f26-9dac-f41418505e8b.png" alt="image.png" class="medium-zoom-image"></p>
<p>由于使用 CDN 会引入额外的开销，此处不采用。这种优化方式更适用于有实际收入的项目。</p>
<h4>4、下载优化 - 流式处理<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4255510790893495</span></h4>
<p>下载大文件时，除了下载慢之外，还可能会占用服务器的内存、硬盘空间，导致资源紧张。</p>
<p>所以，如果文件较大、并且服务端不用处理文件，可以选用流式处理，通过循环的方式，持续从 <code>COSObjectInputStream</code> 读取数据并写进响应输出流，防止过大的文件占满内存。</p>
<p>示例代码如下：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.08544823830576798</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">// 设置响应头</span>
response.setHeader(HttpHeaders.CONTENT_DISPOSITION, <span class="hljs-string">"attachment; filename="</span> + fileName);
response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);

<span class="hljs-comment">// 将 InputStream 写入到 HttpServletResponse 的 OutputStream<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.04123236745925429</span></span>
<span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">out<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9047660949601581</span></span> <span class="hljs-operator">=</span> response.getOutputStream()) {
    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.36460395915160637</span></span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4096</span>];
    <span class="hljs-type">int<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.11248524767125478</span></span> bytesRead;

    <span class="hljs-keyword">while</span> ((bytesRead = cosObjectInput.read(buffer)) != -<span class="hljs-number">1</span>) {
        out.write(buffer, <span class="hljs-number">0<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6591884984478127</span></span>, bytesRead);
    }
} <span class="hljs-keyword">catch</span> (IOException e) {
    <span class="hljs-comment">// 处理异常</span>
    e.printStackTrace();
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9653566133688241</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8410138703831513</span></pre>
<p>在前端进行测试，发现采用这种方式后，下载文件时响应内容的大小会逐渐递增，而不是阻塞半天后一次性得到完整的响应结果。</p>
<p>但是经过测试发现，大文件整体的下载时间并没有得到明显的减少。因为无论是否流失处理，服务器都要先从 COS 对象存储下载文件，再返回给前端。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.874523928352235</span></p>
<p>那么如果要优化，是否可以不从对象存储下载文件呢？</p>
<h4 data-id="heading-11">5、下载优化 - 本地缓存</h4>
<p>答案是肯定的。代码生成器文件的业务特点是 <strong>读多写少</strong> ，是一个典型的缓存适用场景。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.09169082359841507</span></p>
<p>其实 CDN 本质上就是一种缓存，如果不想使用 CDN 增加开销的话，可以选用本地缓存。不需要引入额外的存储技术，只需要将下载过一次的代码生成器保存在服务器上，之后要下载时，如果服务器已经有下载好的文件，就不用从对象存储获取，直接读取并返回给前端即可。</p>
<p>缓存的 4 个核心要素：</p>
<ol>
<li>缓存哪些内容？</li>
<li>缓存如何淘汰？</li>
<li>缓存 key 如何设计？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8941217868060534</span></li>
<li>如何保证缓存一致性？</li>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.22010848474264555</span></ol>
<p>首先是缓存哪些内容，个人不建议每个文件都缓存，原因是难以控制占用的空间、并且还要考虑每个文件的缓存一致性，会增大开发成本。</p>
<p>而且，如果每个文件都缓存，还需要对象存储么？不就有点像自己实现了一个简单的 CDN 么？</p>
<p>所以此处我们选择一种相对简单的实现方式：手动设置哪些文件需要缓存，并且可以通过接口提前缓存指定文件。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6699612041078038</span></p>
<p>1）在 GeneratorController 中编写一个缓存生成器的接口 <code>cacheGenerator</code>。</p>
<p>代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">/**
 * 缓存代码生成器
 *
 * <span class="hljs-doctag">@param</span> generatorCacheRequest
 * <span class="hljs-doctag">@param</span> request
 * <span class="hljs-doctag">@param<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.08145356868775577</span></span> response
 */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3367732960147174</span></span>
<span class="hljs-meta">@PostMapping("/cache")</span>
<span class="hljs-meta">@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.964040601698104</span></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheGenerator<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3670335709555361</span></span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> GeneratorCacheRequest generatorCacheRequest, HttpServletRequest request, HttpServletResponse response)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7069819121427772</span></span> {
    <span class="hljs-keyword">if</span> (generatorCacheRequest == <span class="hljs-literal">null<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.16547009504101884</span></span> || generatorCacheRequest.getId() &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5506749238588551</span></span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.PARAMS_ERROR);
    }

    <span class="hljs-comment">// 获取生成器</span>
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.42000458255653883</span></span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> generatorCacheRequest.getId();
    <span class="hljs-type">Generator<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8430409658132623</span></span> <span class="hljs-variable">generator</span> <span class="hljs-operator">=</span> generatorService.getById(id);
    <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7788755275266728</span></span> (generator == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.46605055405771756</span></span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.NOT_FOUND_ERROR);
    }

    <span class="hljs-type">String</span> <span class="hljs-variable">distPath<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.43198262096352047</span></span> <span class="hljs-operator">=</span> generator.getDistPath();
    <span class="hljs-keyword">if</span> (StrUtil.isBlank(distPath)) {
        <span class="hljs-keyword">throw<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.1758755691687235</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.NOT_FOUND_ERROR, <span class="hljs-string">"产物包不存在"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.40731420174023647</span></span>);
    }

    <span class="hljs-comment">// 缓存空间</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">zipFilePath<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5602284419157049</span></span> <span class="hljs-operator">=</span> getCacheFilePath(id, distPath);

    <span class="hljs-comment">// 新建文件</span>
    <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5303477500168774</span></span> (!FileUtil.exist(zipFilePath)) {
        FileUtil.touch(zipFilePath);
    }

    <span class="hljs-comment">// 下载生成器</span>
    <span class="hljs-keyword">try</span> {
        cosManager.download(distPath, zipFilePath);
    } <span class="hljs-keyword">catch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8429838267078551</span></span> (InterruptedException e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7134755731957121</span></span>(ErrorCode.SYSTEM_ERROR, <span class="hljs-string">"压缩包下载失败"</span>);
    }
}

<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.29774354023259497</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18860265079092886</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.23365811758168564</span></pre>
<p>2）设计缓存 key</p>
<p>缓存 key 相当于数据的 id，用来唯一标识和查找某个缓存内容。</p>
<p>一般情况下，写入缓存的 key 和读取的 key 是一致的，所以编写一个公共方法来获取缓存 key。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8939060464619011</span></p>
<p>由于没有引入额外的缓存技术，这里的缓存 key 就是文件在服务器上的路径。</p>
<p>代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">/**
 * 获取缓存文件路径
 *
 * <span class="hljs-doctag">@param</span> id
 * <span class="hljs-doctag">@param</span> distPath
 * <span class="hljs-doctag">@return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.06497540514454148</span></span>
 */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7205368718485436</span></span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCacheFilePath<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.004604657170957482</span></span><span class="hljs-params">(<span class="hljs-type">long</span> id, String distPath)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5673323276919786</span></span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">projectPath<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9913408075694763</span></span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">"user.dir"</span>);
    <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.33701768270623167</span></span> <span class="hljs-variable">tempDirPath</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">"%s/.temp/cache/%s"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.610747005717649</span></span>, projectPath, id);
    <span class="hljs-type">String</span> <span class="hljs-variable">zipFilePath</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7758147774812383</span></span> String.format(<span class="hljs-string">"%s/%s"</span>, tempDirPath, distPath);
    <span class="hljs-keyword">return</span> zipFilePath;
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6124078047892618</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4790155466883914</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8307345576632643</span></pre>
<p>3）修改生成器下载接口，优先从缓存获取。</p>
<p>修改后的代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">// 追踪事件</span>
log.info(<span class="hljs-string">"用户 {} 下载了 {}"</span>, loginUser, distPath);

<span class="hljs-comment">// 设置响应头<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5739589944961376</span></span>
response.setContentType(<span class="hljs-string">"application/octet-stream;charset=UTF-8"</span>);
response.setHeader(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment; filename="<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.057720274120669934</span></span> + distPath);

<span class="hljs-comment">// 优先从缓存读取</span>
<span class="hljs-type">String</span> <span class="hljs-variable">zipFilePath<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6932341071656067</span></span> <span class="hljs-operator">=</span> getCacheFilePath(id, distPath);
<span class="hljs-keyword">if</span> (FileUtil.exist(zipFilePath)) {
    <span class="hljs-comment">// 写入响应<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.017686215793683457</span></span>
    Files.copy(Paths.get(zipFilePath), response.getOutputStream());
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-type">COSObjectInputStream</span> <span class="hljs-variable">cosObjectInput<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9670703720210647</span></span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
<span class="hljs-keyword">try<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6108477634661866</span></span> {
    <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6957779945512086</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();
    stopWatch.start();
    <span class="hljs-type">COSObject<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.546512919285925</span></span> <span class="hljs-variable">cosObject</span> <span class="hljs-operator">=</span> cosManager.getObject(distPath);
    cosObjectInput = cosObject.getObjectContent();
    <span class="hljs-comment">// 处理下载到的流<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8154194249246696</span></span>
    <span class="hljs-type">byte</span>[] bytes = IOUtils.toByteArray(cosObjectInput);
    stopWatch.stop();
    System.out.println(stopWatch.getTotalTimeMillis());
    <span class="hljs-comment">// 写入响应</span>
    response.getOutputStream().write(bytes);
    response.getOutputStream().flush();
} <span class="hljs-keyword">catch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2811095847900391</span></span> (Exception e) {
    log.error(<span class="hljs-string">"file download error, filepath = "</span> + distPath, e);
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7697586204289093</span></span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="hljs-string">"下载失败"</span>);
} <span class="hljs-keyword">finally<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9573597274391916</span></span> {
    <span class="hljs-keyword">if</span> (cosObjectInput != <span class="hljs-literal">null</span>) {
        cosObjectInput.close();
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.36324027414995097</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8022221175172999</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9539838750555556</span></pre>
<p>4）测试调用</p>
<p>首先执行缓存接口，提前下载一个大文件。然后调用接口下载该文件，使用 F12 网页控制台查看下载接口耗时。</p>
<p>测试发现，使用文件缓存后，接口响应时长大幅缩短！只需 100 多毫秒就能完成下载，快了 100 多倍！<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5912996039017377</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/b1e628c8-7458-4cbb-957b-0123d96a1bbb.png" alt="image.png" class="medium-zoom-image"></p>
<p>对于热门的代码生成器，采用本地缓存的方式不仅能大大减少下载时长，还能节约对象存储的流量开销，两全其美。</p>
<p>不过，以上只是跑通了流程，演示了缓存的效果。实际项目开发中，还应该做以下几点：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7457146483943016</span></p>
<p>1）除了调用接口缓存外，还可以通过一些方法自动识别出热点生成器并缓存。比如增加使用次数字段统计使用情况，然后通过定时任务（或者每次下载后）检测使用情况是否超过热点阈值，超过的话表示是热点数据，设置缓存。</p>
<blockquote>
<p>推荐了解开源的热 key 发现系统，京东 HotKey：<a href="https://gitee.com/jd-platform-opensource/hotkey">https://gitee.com/jd-platform-opensource/hotkey</a></p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8544535576460071</span></blockquote>
<p>2）设置合适的缓存淘汰机制。比如编写一个清理缓存的接口，人工定期清理；或者给缓存设置一个过期时间，通过定时任务定期清理。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.43057287222544227</span></p>
<p>3）保证缓存一致性。如果用户重新上传了代码生成器文件，应该保证用户下载到的不是缓存而是最新的文件。最简单的实现方式就是更新时删除缓存，还可以使用延迟双删等策略。对于我们的系统来说，缓存一致性要求并不高，感兴趣的同学可以自行了解实现。</p>
<h3 data-id="heading-12">使用生成器接口</h3>
<p>下面尝试优化使用生成器接口。相比生成器下载，这个接口的逻辑更复杂，耗时操作可能包括下载文件、执行脚本、压缩解压等。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6974568395155787</span></p>
<h4 data-id="heading-13">1、整体测试</h4>
<p>首先进入到使用生成器页面，按 F12 打开网络请求控制台，先整体测试使用接口的耗时：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/e81761eb-a5fb-449a-b0b7-4e172dd6af87.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4421337459230954</span></p>
<p>大概 2 - 3 秒左右，应该是有优化空间的。</p>
<h4 data-id="heading-14">2、分析代码耗时</h4>
<p>接下来通过 StopWatch 对使用生成器的各个关键操作进行耗时统计，代码如下：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.29494434973865347</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-meta">@PostMapping("/use")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7233465887671426</span></span> <span class="hljs-title function_">useGenerator</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> GeneratorUseRequest generatorUseRequest, HttpServletRequest request, HttpServletResponse response)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.04415576052380765</span></span> <span class="hljs-keyword">throws<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18232519775565414</span></span> IOException {
    <span class="hljs-comment">// 1）用户在前端输入模型参数</span>
    <span class="hljs-type">Long</span> <span class="hljs-variable">id<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.832011215912037</span></span> <span class="hljs-operator">=</span> generatorUseRequest.getId();
    Map&lt;String, Object&gt; dataModel = generatorUseRequest.getDataModel();

    <span class="hljs-comment">// 需要登录</span>
    <span class="hljs-type">User<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9794760946769951</span></span> <span class="hljs-variable">loginUser</span> <span class="hljs-operator">=</span> userService.getLoginUser(request);
    <span class="hljs-type">Generator<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4519498785715985</span></span> <span class="hljs-variable">generator</span> <span class="hljs-operator">=</span> generatorService.getById(id);
    <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9214465493176658</span></span> (generator == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8677569934400997</span></span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.NOT_FOUND_ERROR);
    }

    <span class="hljs-comment">// 2）从对象存储上下载生成器压缩包，到一个独立的工作空间</span>
    <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3727403183825919</span></span> <span class="hljs-variable">distPath</span> <span class="hljs-operator">=</span> generator.getDistPath();
    <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.17514606453305048</span></span> (StrUtil.isBlank(distPath)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6343344235177992</span></span>(ErrorCode.NOT_FOUND_ERROR, <span class="hljs-string">"产物包不存在"</span>);
    }

    <span class="hljs-comment">// 工作空间</span>
    <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9204124682974228</span></span> <span class="hljs-variable">projectPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">"user.dir"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9541611361789306</span></span>);
    <span class="hljs-type">String</span> <span class="hljs-variable">tempDirPath</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.16244449767367586</span></span> String.format(<span class="hljs-string">"%s/.temp/use/%s"</span>, projectPath, id);
    <span class="hljs-type">String</span> <span class="hljs-variable">zipFilePath<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9795434656937496</span></span> <span class="hljs-operator">=</span> tempDirPath + <span class="hljs-string">"/dist.zip"</span>;

    <span class="hljs-comment">// 新建文件<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9767855598336004</span></span>
    <span class="hljs-keyword">if</span> (!FileUtil.exist(zipFilePath)) {
        FileUtil.touch(zipFilePath);
    }

    <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4610633211086441</span></span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6760697518840209</span></span>();
    stopWatch.start();
    <span class="hljs-comment">// 下载文件</span>
    <span class="hljs-keyword">try</span> {
        cosManager.download(distPath, zipFilePath);
    } <span class="hljs-keyword">catch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7889226763153172</span></span> (InterruptedException e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.014896202461734065</span></span>(ErrorCode.SYSTEM_ERROR, <span class="hljs-string">"生成器下载失败"</span>);
    }
    stopWatch.stop();
    System.out.println(<span class="hljs-string">"下载："</span> + stopWatch.getTotalTimeMillis());

    <span class="hljs-comment">// 3）解压，得到生成器<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.09533951538949981</span></span>
    stopWatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();
    stopWatch.start();
    <span class="hljs-type">File<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7478203348750723</span></span> <span class="hljs-variable">unzipDistDir</span> <span class="hljs-operator">=</span> ZipUtil.unzip(zipFilePath);
    stopWatch.stop();
    System.out.println(<span class="hljs-string">"解压："<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.41337118241778237</span></span> + stopWatch.getTotalTimeMillis());

    <span class="hljs-comment">// 4）将用户输入的参数写入到 json 文件中</span>
    stopWatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3907527563490232</span></span>();
    stopWatch.start();
    <span class="hljs-type">String</span> <span class="hljs-variable">dataModelFilePath</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.49847679691223523</span></span> tempDirPath + <span class="hljs-string">"/dataModel.json"</span>;
    <span class="hljs-type">String</span> <span class="hljs-variable">jsonStr<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4646230253383019</span></span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(dataModel);
    FileUtil.writeUtf8String(jsonStr, dataModelFilePath);
    stopWatch.stop();
    System.out.println(<span class="hljs-string">"写数据文件："</span> + stopWatch.getTotalTimeMillis());

    <span class="hljs-comment">// 5）执行脚本，构造脚本调用命令，传入模型参数 json 文件路径，调用脚本并生成代码<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3452839036638564</span></span>
    <span class="hljs-comment">// 找到脚本文件所在路径</span>
    <span class="hljs-type">File</span> <span class="hljs-variable">scriptFile<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.015271208012176407</span></span> <span class="hljs-operator">=</span> FileUtil.loopFiles(unzipDistDir, <span class="hljs-number">2</span>, <span class="hljs-literal">null<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6259385327320699</span></span>).stream()
            .filter(file -&gt; file.isFile() &amp;&amp; <span class="hljs-string">"generator"</span>.equals(file.getName()))
            .findFirst()
            .orElseThrow(RuntimeException::<span class="hljs-keyword">new</span>);

    <span class="hljs-comment">// 添加可执行权限<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6960997664838848</span></span>
    <span class="hljs-keyword">try</span> {
        Set&lt;PosixFilePermission&gt; permissions = PosixFilePermissions.fromString(<span class="hljs-string">"rwxrwxrwx"</span>);
        Files.setPosixFilePermissions(scriptFile.toPath(), permissions);
    } <span class="hljs-keyword">catch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2818564596412776</span></span> (Exception e) {

    }

    <span class="hljs-comment">// 构造命令</span>
    <span class="hljs-type">File</span> <span class="hljs-variable">scriptDir<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.13314018771258573</span></span> <span class="hljs-operator">=</span> scriptFile.getParentFile();
    String[] commands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.45381666632538153</span></span>[]{<span class="hljs-string">"./generator"</span>, <span class="hljs-string">"json-generate"</span>, <span class="hljs-string">"--file="<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9954688143608184</span></span> + dataModelFilePath};
    <span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">processBuilder</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.22570582630170066</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(commands);
    processBuilder.directory(scriptDir);

    <span class="hljs-keyword">try<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8237862689186073</span></span> {
        stopWatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();
        stopWatch.start();
        <span class="hljs-type">Process<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.06800579759298198</span></span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> processBuilder.start();

        <span class="hljs-comment">// 读取命令的输出<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.392212469078141</span></span>
        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5673398842296813</span></span> process.getInputStream();
        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.48221058312534426</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7204126502102446</span></span> <span class="hljs-title class_">InputStreamReader</span>(inputStream));
        String line;
        <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.635324046820023</span></span>) {
            System.out.println(line);
        }

        <span class="hljs-comment">// 等待命令执行完成</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">exitCode<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7490707212336529</span></span> <span class="hljs-operator">=</span> process.waitFor();
        System.out.println(<span class="hljs-string">"命令执行结束，退出码："</span> + exitCode);
        stopWatch.stop();
        System.out.println(<span class="hljs-string">"执行脚本："<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9533841505025631</span></span> + stopWatch.getTotalTimeMillis());
    } <span class="hljs-keyword">catch</span> (Exception e) {
        e.printStackTrace();
    }

    <span class="hljs-comment">// 6）返回生成的代码结果压缩包</span>
    <span class="hljs-comment">// 生成代码的位置<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.500019406817066</span></span>
    stopWatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();
    stopWatch.start();
    <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6430436151841106</span></span> <span class="hljs-variable">generatedPath</span> <span class="hljs-operator">=</span> scriptDir.getAbsolutePath() + <span class="hljs-string">"/generated"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5774472613343506</span></span>;
    <span class="hljs-type">String</span> <span class="hljs-variable">resultPath</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.003355528968136845</span></span> tempDirPath + <span class="hljs-string">"/result.zip"</span>;
    <span class="hljs-type">File</span> <span class="hljs-variable">resultFile<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.914360818037895</span></span> <span class="hljs-operator">=</span> ZipUtil.zip(generatedPath, resultPath);
    stopWatch.stop();
    System.out.println(<span class="hljs-string">"压缩结果："</span> + stopWatch.getTotalTimeMillis());

    <span class="hljs-comment">// 下载文件<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.11054706131993552</span></span>
    <span class="hljs-comment">// 设置响应头</span>
    response.setContentType(<span class="hljs-string">"application/octet-stream;charset=UTF-8"</span>);
    response.setHeader(<span class="hljs-string">"Content-Disposition"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7888647614385198</span></span>, <span class="hljs-string">"attachment; filename="</span> + resultFile.getName());
    <span class="hljs-comment">// 写入响应</span>
    Files.copy(resultFile.toPath(), response.getOutputStream());

    <span class="hljs-comment">// 7）清理文件<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.007213453018400262</span></span>
    CompletableFuture.runAsync(() -&gt; {
        FileUtil.del(tempDirPath);
    });
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.936771397294927</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6788876761663412</span></pre>
<p>测试结果如下图（单位为毫秒）：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/0a728fee-b49b-476b-813e-0dc322260d4a.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9901821861699862</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/c8ff1e99-b4cc-4d52-926e-49e6ff541b19.png" alt="image.png" class="medium-zoom-image"></p>
<h4 data-id="heading-15">3、优化策略</h4>
<p>分析上图并且按照耗时程度排序，发现下载、执行脚本、解压都是耗时操作。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.19052860717451514</span></p>
<p>由于生成器脚本是由 maker 制作工具提前生成好的，执行脚本的操作优化可能比较困难。虽然可以优化，比如多线程并发生成文件，但是复杂度过高、优化的性价比不高。</p>
<p>所以，我们重点优化下载和解压操作。对于频繁使用的生成器，反复下载文件、解压文件是没必要的，可以像下载生成器接口一样使用缓存，此处不再赘述。</p>
<blockquote>
<p>扩展：由于下载和使用生成器这两个接口都需要下载相同的代码生成器文件，所以文件缓存是可以复用共享的。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2889655252277816</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5658122198200586</span></blockquote>
<h3 data-id="heading-16">制作生成器接口</h3>
<h4 data-id="heading-17">1、整体测试</h4>
<p>跟之前一样，先测试接口的整体耗时。以制作一个 ACM 模板项目生成器为例，测试结果如下：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8882140192456951</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/64973054-f2b1-4a5a-a296-41f8d4e8f33e.png" alt="image.png" class="medium-zoom-image"></p>
<p>平均每次制作要花费 3 秒左右，应该是有一定优化空间的。</p>
<h4>2、分析代码耗时<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.1263683232854964</span></h4>
<p>接下来通过 StopWatch 对接口的各个关键操作进行耗时统计，代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">try</span> {
    <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3069269342890244</span></span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6297795928084655</span></span>();
    stopWatch.start();
    cosManager.download(zipFilePath, localZipFilePath);
    stopWatch.stop();
    System.out.println(<span class="hljs-string">"下载文件："</span> + stopWatch.getTotalTimeMillis());
} <span class="hljs-keyword">catch</span> (InterruptedException e) {
    <span class="hljs-keyword">throw<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8655481572479333</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="hljs-string">"压缩包下载失败"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7267409296003093</span></span>);
}

<span class="hljs-comment">// 3）解压，得到项目模板文件</span>
<span class="hljs-type">File</span> <span class="hljs-variable">unzipDistDir<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7825601919517973</span></span> <span class="hljs-operator">=</span> ZipUtil.unzip(localZipFilePath);

<span class="hljs-comment">// 4）构造 meta 对象和输出路径</span>
<span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9468145967623853</span></span> <span class="hljs-variable">sourceRootPath</span> <span class="hljs-operator">=</span> unzipDistDir.getAbsolutePath();
meta.getFileConfig().setSourceRootPath(sourceRootPath);
MetaValidator.doValidAndFill(meta);
<span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.311539347266685</span></span> <span class="hljs-variable">outputPath</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">"%s/generated/%s"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.09161861745716116</span></span>, tempDirPath, meta.getName());

<span class="hljs-comment">// 5）调用 maker 方法制作生成器</span>
<span class="hljs-type">GenerateTemplate</span> <span class="hljs-variable">generateTemplate<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4311300771878275</span></span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipGenerator<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18459431380953428</span></span>();
<span class="hljs-keyword">try</span> {
    <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7130728891374571</span></span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8872785735538837</span></span>();
    stopWatch.start();
    generateTemplate.doGenerate(meta, outputPath);
    stopWatch.stop();
    System.out.println(<span class="hljs-string">"制作："</span> + stopWatch.getTotalTimeMillis());
} <span class="hljs-keyword">catch</span> (Exception e) {
    e.printStackTrace();
    <span class="hljs-keyword">throw<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18005627194226093</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="hljs-string">"制作失败"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8970917652390145</span></span>);
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8078274514103803</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2377212047057975</span></pre>
<p>测试结果如下图（单位为毫秒）：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.45499965537847387</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/7e1c56a1-4f9b-451e-8303-dd1ceb0cfe2c.png" alt="image.png" class="medium-zoom-image"></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/90781fe4-eff2-4465-a3c5-cc5b4eb9c32f.png" alt="image.png" class="medium-zoom-image"></p>
<h4>3、优化策略<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.29959259807813776</span></h4>
<p>分析上图，发现主要的耗时操作是下载和制作。</p>
<p>先优化下载耗时。分析下载流程，先让用户将模板文件上传到对象存储、再从对象存储下载的过程其实是没必要的。因为平台现在仅支持单次制作，制作完成后，用户上传的模板文件就没用了。所以不如直接通过请求参数传递原始文件给后端，既节约了对象存储资源、又提升了性能。</p>
<p>这里作为一个扩展点，感兴趣的同学可以自主实现。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5811490621689608</span></p>
<p>虽然制作操作耗时比下载耗时更多，但其实 2 - 3 秒是可以接受的范围，而且由于调用了 maker 项目、使用 Maven 进行打包，优化的成本较大，此处暂不考虑。（应该也是需要多线程并发）</p>
<p>如果制作耗时超过 20 秒，可以考虑使用 <strong>异步化</strong> ，将生成器制作封装为一个任务，用户可以通过前端页面自主查询任务的执行状态并下载制作结果。</p>
<blockquote>
<p>关于异步化的实现，之前鱼皮在智能 BI 项目和 OJ 判题项目中都完整讲过。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.179772730192433</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6535394329361841</span></blockquote>
<h2 data-id="heading-20">三、查询性能优化</h2>
<p>刚才我们主要对文件下载相关业务场景进行了性能优化，下面我们再优化一个典型的业务场景 —— 数据查询。</p>
<p>什么情况下需要对数据查询进行性能优化呢？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8784697547833498</span></p>
<p>一般有以下几个场景：</p>
<ol>
<li>数据需要高频访问</li>
<li>数据量较大，查询缓慢</li>
<li>数据查询实时性要求高，追求用户体验<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.37716509733763304</span></li>
</ol>
<p>对于我们的代码生成项目，主页代码生成器列表的访问频率应该是最高的，而且主页一般也需要有较快的加载速度，所以本小节我们就来优化主页调用的 <strong>分页查询生成器接口</strong> 。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7178310415129576</span></p>
<p>通过这个例子，给大家分享常用的数据查询接口优化方法。</p>
<h3 data-id="heading-21">方法一、精简数据</h3>
<p>目前，整个系统的数据量不大，我们先不考虑高并发，从最简单的优化开始做起，目标是减少接口的响应时长，从而提高页面的加载速度。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8417569399810791</span></p>
<h4 data-id="heading-22">1、整体测试</h4>
<p>首先修改前端页面，让主页每页展示 12 条数据，并且通过修改数据库，保证首页的 12 条数据都是完整的，尤其是都要有 <code>fileConfig</code> 和 <code>modelConfig</code> 字段。</p>
<p>如下图：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.29730345897133037</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/d8dcc88d-4cbf-4b39-a275-cdb90f5e5ef5.png" alt="image.png" class="medium-zoom-image"></p>
<p>通过网页控制台查看接口整体的查询耗时，发现最大值超过了 150 毫秒：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/62896e72-69b4-4047-ac26-b7b8df304f9b.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5595500564078848</span></p>
<p>多测试几次查看平均值，查询 10 次的耗时如下图，平均 100 毫秒左右：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/b612968e-809b-49bb-800a-138f422b8d06.png" alt="image.png" class="medium-zoom-image"></p>
<h4>2、分析代码耗时<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2982851935061237</span></h4>
<p>接下来通过 StopWatch 对接口的各个关键操作进行耗时统计，代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">/**
 * 分页获取列表（封装类）
 *
 * <span class="hljs-doctag">@param</span> generatorQueryRequest
 * <span class="hljs-doctag">@param</span> request
 * <span class="hljs-doctag">@return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.41557653149660134</span></span>
 */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4722195603514747</span></span>
<span class="hljs-meta">@PostMapping("/list/page/vo")</span>
<span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9390408857228336</span></span> BaseResponse&lt;Page&lt;GeneratorVO&gt;&gt; <span class="hljs-title function_">listGeneratorVOByPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> GeneratorQueryRequest generatorQueryRequest,
                                                             HttpServletRequest request)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6271839414415559</span></span> {
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7553163253316681</span></span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> generatorQueryRequest.getCurrent();
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.48361028457040134</span></span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> generatorQueryRequest.getPageSize();
    <span class="hljs-comment">// 限制爬虫<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.16746110483550591</span></span>
    ThrowUtils.throwIf(size &gt; <span class="hljs-number">20</span>, ErrorCode.PARAMS_ERROR);
    <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6890252686289693</span></span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5329618541531125</span></span>();
    stopWatch.start();
    Page&lt;Generator&gt; generatorPage = generatorService.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, size),
            generatorService.getQueryWrapper(generatorQueryRequest));
    stopWatch.stop();
    System.out.println(<span class="hljs-string">"查询生成器："<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7398621465331612</span></span> + stopWatch.getTotalTimeMillis());
    stopWatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();
    stopWatch.start();
    Page&lt;GeneratorVO&gt; generatorVOPage = generatorService.getGeneratorVOPage(generatorPage, request);
    stopWatch.stop();
    System.out.println(<span class="hljs-string">"查询关联数据："<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5301371452526447</span></span> + stopWatch.getTotalTimeMillis());
    <span class="hljs-keyword">return</span> ResultUtils.success(generatorVOPage);
}

<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5600820764115109</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2484805569962234</span></pre>
<p>经过多次测试，发现 2 个数据库查询操作的总耗时接近 100 毫秒：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.41445723957674474</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/a61ff1df-56d9-4b95-9507-3fc4c9dd5f63.png" alt="image.png" class="medium-zoom-image"></p>
<p>奇怪了，2 个数据库查询操作才耗时接近 100 毫秒，为什么整个接口的响应需要 150 毫秒呢？</p>
<p>原因是服务器查询到数据后，还需要传输数据给前端，存在一个下载耗时。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.08790457024281984</span></p>
<p>在网页控制台中查看请求消耗的时间，发现前端下载内容花费了额外的时间，如下图：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/dfabc7dd-3e15-4bcd-b3be-8a8869e716f4.png" alt="image.png" class="medium-zoom-image"></p>
<h4>3、优化<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05366580986449754</span></h4>
<p>如何减少前端下载内容的时间呢？</p>
<p>很简单，2 种方法：</p>
<ol>
<li>减少后端返回的数据体积，可以减少返回的数据、或者压缩数据</li>
<li>提高服务器的带宽</li>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2566031639240707</span></ol>
<p>显然，第一种方法的成本是最低的，所以我们可以尝试精简数据，只让后端返回主页需要展示的数据。像文件配置（fileConfig）、模型配置（modelConfig）都不是必要的。</p>
<p>1）在 GeneratorController 中编写一个新的数据查询接口 <code>listGeneratorVOByPageFast</code>，而不是修改老的接口，便于查看对比效果。</p>
<p>这个接口的逻辑和之前的数据查询一致，只是在查询到数据后，将部分多余的字段值设置为 null，不再返回。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3487628797394422</span></p>
<p>代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">/**
 * 快速分页获取列表（封装类）
 *
 * <span class="hljs-doctag">@param</span> generatorQueryRequest
 * <span class="hljs-doctag">@param</span> request
 * <span class="hljs-doctag">@return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2394672818538255</span></span>
 */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2551100873926593</span></span>
<span class="hljs-meta">@PostMapping("/list/page/vo/fast")</span>
<span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05374985270087285</span></span> BaseResponse&lt;Page&lt;GeneratorVO&gt;&gt; <span class="hljs-title function_">listGeneratorVOByPageFast</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> GeneratorQueryRequest generatorQueryRequest,
                                                             HttpServletRequest request)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.849288453300411</span></span> {
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0397405468474894</span></span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> generatorQueryRequest.getCurrent();
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7998948243968722</span></span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> generatorQueryRequest.getPageSize();
    <span class="hljs-comment">// 限制爬虫<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.06969545373871289</span></span>
    ThrowUtils.throwIf(size &gt; <span class="hljs-number">20</span>, ErrorCode.PARAMS_ERROR);
    Page&lt;Generator&gt; generatorPage = generatorService.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.39555057525425075</span></span>&lt;&gt;(current, size),
            generatorService.getQueryWrapper(generatorQueryRequest));
    Page&lt;GeneratorVO&gt; generatorVOPage = generatorService.getGeneratorVOPage(generatorPage, request);
    generatorVOPage.getRecords().forEach(generatorVO -&gt; {
        generatorVO.setFileConfig(<span class="hljs-literal">null</span>);
        generatorVO.setModelConfig(<span class="hljs-literal">null</span>);
    });
    <span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7529209499081579</span></span> ResultUtils.success(generatorVOPage);
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3281296031126619</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5637720267612414</span></pre>
<p>2）前端修改主页调用的接口<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0973622487241077</span></p>
<p>修改的代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">tsx</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-tsx hljs language-typescript" data-highlighted="yes"><span class="hljs-comment">/**
 * 搜索
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">doSearch<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.335509772962848</span></span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-title function_">setLoading<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6091975622119445</span></span>(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2723127061645325</span></span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">listGeneratorVoByPageFastUsingPost</span>(searchParams);
    <span class="hljs-title function_">setDataList<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.39491769455192305</span></span>(res.<span class="hljs-property">data</span>?.<span class="hljs-property">records</span> ?? []);
    <span class="hljs-title function_">setTotal<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6417889021746328</span></span>(<span class="hljs-title class_">Number</span>(res.<span class="hljs-property">data</span>?.<span class="hljs-property">total<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8925154382278655</span></span>) ?? <span class="hljs-number">0</span>);
  } <span class="hljs-keyword">catch</span> (<span class="hljs-attr">error<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.33039058215940487</span></span>: <span class="hljs-built_in">any</span>) {
    message.<span class="hljs-title function_">error</span>(<span class="hljs-string">'获取数据失败，'<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8371525288683215</span></span> + error.<span class="hljs-property">message</span>);
  }
  <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.09884066674206715</span></span>);
};
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.27087077225215195</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9047087727981609</span></pre>
<h4>4、测试<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5136465190372439</span></h4>
<p>跟之前一样，测试查询 10 次的平均耗时，大概 85 毫秒左右，显然是比原来的 100 毫秒要快的，接口平均响应时长减少了 15%。</p>
<p>如下图：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/58f9b5d6-6d9d-48cd-b7f9-22a2a1db9ad8.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3386059760185065</span></p>
<p>而且查询的原始数据量越大，优化效果越明显。</p>
<h3 data-id="heading-26">方法二、SQL 优化</h3>
<p>接下来让我们增加系统的数据量，完成进一步的性能优化。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.280255624293267</span></p>
<p>首先向数据库插入 10 万条示例数据（ACM 示例模板生成器），模拟真实的系统用量。</p>
<p>可以通过编写单元测试来实现数据的批量插入，读取一条现有数据并循环插入即可，代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">package</span> com.yupi.web.service;

<span class="hljs-keyword">import</span> com.yupi.web.model.entity.Generator;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4798410183629689</span></span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-meta">@SpringBootTest<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4536035622586836</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorServiceTest</span> {

    <span class="hljs-meta">@Resource<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9331023980375923</span></span>
    <span class="hljs-keyword">private</span> GeneratorService generatorService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.20540586938201177</span></span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8215132989069636</span></span> {
        <span class="hljs-type">Generator</span> <span class="hljs-variable">generator</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9420855156918133</span></span> generatorService.getById(<span class="hljs-number">18L</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9914406382834644</span></span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.35992125456735</span></span>; i &lt; <span class="hljs-number">100000</span>; i++) {
            generator.setId(<span class="hljs-literal">null</span>);
            generatorService.save(generator);
        }
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.46254742610274935</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.21944441331605757</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6223219925249133</span></pre>
<h4 data-id="heading-27">1、整体测试</h4>
<p>通过网页控制台查看接口整体的查询耗时，显然插入大量数据后，性能大幅降低，接口平均响应时长耗时 300 多毫秒：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/37a1a41e-a799-4e36-8b9d-a5a403d0e6d9.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6403065177600205</span></p>
<p>在实际业务中，10 万条数据其实是个正常（甚至偏小）的数据量级，如果数据量上百万、千万，查询性能肯定会更低，所以必须要进一步优化。</p>
<h4 data-id="heading-28">2、分析耗时</h4>
<p>由于数据量增大导致查询性能降低，所以我们很容易想到是数据库查询数据的耗时增大了，因此我们要做的就是优化数据库的查询。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4686361901763856</span></p>
<p>1）首先从业务日志中找到查询对应的 SQL 语句，如下图：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/bdac233b-79a4-4503-97e1-7523301bb1b7.png" alt="image.png" class="medium-zoom-image"></p>
<p>可以复制上述语句到 SQL 执行控制台，补充参数后，连续执行 10 次观察耗时。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7795672507535896</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/827b48f1-c39f-455a-baef-32e784075e70.png" alt="image.png" class="medium-zoom-image"></p>
<p>SQL 语句如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">sql</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-sql hljs" data-highlighted="yes"><span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6884391528697753</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2508365516522959</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.07603179080972589</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0721230810568434</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8485513740357677</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5195700294842582</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4363082887319609</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7881249354424538</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.814241225833312</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.24597908895681564</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2407593518299811</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.17121257286370972</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8841193859177505</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5059681274114483</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.38927960417163865</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8430642140802713</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3385326726685465</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9848064768104619</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.659898162981494</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.049762647741346866</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9004121137896994</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7233941941749413</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.027576964694755013</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9751022195542269</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.11881946063210025</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5501741669485971</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.018987844899919892</span></span>;
<span class="hljs-keyword">SELECT</span> id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete <span class="hljs-keyword">FROM</span> generator <span class="hljs-keyword">WHERE<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8882517122554472</span></span> isDelete<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">ORDER<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4230598863027881</span></span> <span class="hljs-keyword">BY</span> createTime <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">12<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0791487225406049</span></span>;
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4412427361860838</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9361383169010085</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.30957260323096336</span></pre>
<p>执行总耗时 1171 毫秒：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/1e032daa-ace3-4903-97e4-d6ad08048392.png" alt="image.png" class="medium-zoom-image"></p>
<h4>3、优化<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5031586716870426</span></h4>
<p>如何优化数据库查询呢？</p>
<p>最常见的几种方案：</p>
<ol>
<li>减少查询次数，能不查数据库就不查数据库，比如使用缓存。</li>
<li>优化 SQL 语句</li>
<li>添加合适的索引<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5052199730877804</span></li>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.35185520143243876</span></ol>
<p>进行优化时，我们优先选择成本最低的方案。</p>
<p>第 1 种方案通常需要引入额外的技术（缓存），所以等下我们再考虑。</p>
<p>第 3 种方案虽然改动成本不高，但是对于我们的主页查询，默认并没有任何的查询条件（除了 isDelete = 0），所以也不适用于添加索引来优化。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7809060945513524</span></p>
<p>所以我们目前最应该做的，就是优化 SQL 语句。既然有些字段不需要在主页展示，那我们是不是都不用从数据库中查出这些字段了呢？</p>
<p>在 SQL 控制台测试一下，如果不查询 fileConfig 和 modelConfig 字段，执行 10 次的总耗时 1020 毫秒，减少 10% 左右。</p>
<p>如下图，说明方案可行：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8886749141277386</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/057760aa-a459-4689-96dd-fdc3fe082ef7.png" alt="image.png" class="medium-zoom-image"></p>
<p>修改对应的代码，只查询需要的字段：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes">QueryWrapper&lt;Generator&gt; queryWrapper = generatorService.getQueryWrapper(generatorQueryRequest);
queryWrapper.select(<span class="hljs-string">"id"</span>,<span class="hljs-string">"name"</span>,<span class="hljs-string">"description"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7340363852112941</span></span>,<span class="hljs-string">"tags"</span>,<span class="hljs-string">"picture"</span>,<span class="hljs-string">"status"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9237687947729156</span></span>,<span class="hljs-string">"userId"</span>,<span class="hljs-string">"createTime"</span>,<span class="hljs-string">"updateTime"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18257683196977847</span></span>);
Page&lt;Generator&gt; generatorPage = generatorService.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, size), queryWrapper);
Page&lt;GeneratorVO&gt; generatorVOPage = generatorService.getGeneratorVOPage(generatorPage, request);
<span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.43023057881998983</span></span> ResultUtils.success(generatorVOPage);
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.10490764965423005</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8728892780436384</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7196381057817549</span></pre>
<h4 data-id="heading-25">4、测试</h4>
<p>优化后，再次进行测试，发现接口的平均响应时间优化到了 200 多毫秒，减少了 1/3！</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/5562cbaf-cc25-412f-81b1-8a8f301b4c92.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2911074890867744</span></p>
<p>有时候，就是这么简单的优化，只要你能想到，就能大幅提升性能。</p>
<blockquote>
<p>扩展：分页查询接口中，还有一个耗时的操作 —— 使用 count 语句统计总数，是否可以优化呢？</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6402317664368775</span></blockquote>
<p>一般来说，单次查询时间超过 100ms、500ms 或者 1s 算是慢查询。目前接口的性能还可以，能够应对用户量不大的场景。但如果同时使用系统的用户增多、并发量增大呢？我们又该如何优化系统？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.38479537325059754</span></p>
<h3 data-id="heading-31">方法三、压力测试</h3>
<p>在进行优化前，首先我们要掌握一个重要的性能测试方法 —— 压力测试。</p>
<p>由于我们的系统并没有那么多的并发请求，所以必须通过压力测试工具，通过造线程模拟真实用户请求的方式，来实现高并发测试。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.14891611387603243</span></p>
<p>下面我们就用主流的压力测试工具 Apache JMeter，给大家演示如何模拟高并发场景来测试接口。</p>
<h4 data-id="heading-32">0、明确测试情况</h4>
<p>首先，一定要明确测试的环境、条件和基准。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2963149618694878</span></p>
<p>举个例子，鱼皮本次的测试情况：</p>
<ul>
<li>环境：使用 16 G 内存、10 核 CPU、百兆带宽的网速</li>
<li>条件：每次请求相同的接口、传递相同的参数</li>
<li>基准：始终保证接口异常率 0%，出现异常则需要重新测试<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.02837293340296254</span></li>
</ul>
<p><strong>注意，压测前保证不会影响系统的正常运行，千万不要在线上压测！</strong><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.32675184274213165</span></p>
<blockquote>
<p>线上压测 ≈ 造事故 ≈ 攻击</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.19349234058958764</span></blockquote>
<h4 data-id="heading-33">1、下载 JMeter</h4>
<p>直接在官网下载 Apache JMeter，地址：<a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4619501924259719</span></p>
<p>安装包：apache-jmeter-5.6.3</p>
<p>阿里云盘：<a href="https://www.alipan.com/s/USLx7QYBwwt">https://www.alipan.com/s/USLx7QYBwwt</a>
提取码: 28gu</p>
<p>下载后解压，然后执行 bin 目录下的 jar 包即可：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0831463278029696</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/b6f2f566-5cde-40f5-a3f6-f8201458fb24.png" alt="image.png" class="medium-zoom-image"></p>
<h4 data-id="heading-34">2、压测配置</h4>
<p>1）创建线程组<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.017759227664460697</span></p>
<p>先创建一个线程组，主要是填写线程数、启动时间、循环次数这 3 个值。</p>
<ul>
<li>线程数 * 循环次数 = 要测试的请求总数</li>
<li>启动时间的作用是控制线程的启动速率，从而控制请求速率。举个例子，10 秒启动 100 个线程，那么每秒启动 10 个线程，相当于最开始每秒会发 10 个请求。</li>
</ul>
<p>建议根据自己的实际测试结果动态调整线程组，直到找到一个每次测试结果相对稳定的设置，从而消除线程组启动或者电脑配置不足导致的误差。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.32807222113171886</span></p>
<p>但是要注意，每秒启动的线程数要大于接口的 qps（每秒请求数），才能测试到极限，不能因为请求速度不够影响测试结果。</p>
<p>这里我们统一性能测试标准：</p>
<ul>
<li>线程数：1000 个 / 组</li>
<li>启动时长：10 秒</li>
<li>循环次数：10 组<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.35223770763559026</span></li>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3953046113645138</span></ul>
<p>如下图：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/c5a5c5d5-5e1f-4788-b130-9114c4c83d64.png" alt="image.png" class="medium-zoom-image"></p>
<p>2）创建 HTTP 信息头管理<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.15528382028855514</span></p>
<p>可以自主添加请求头，比如设置请求 <code>Content-Type</code> 为 <code>application/json</code>，和我们要测试的接口保持一致。</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/df012042-569d-4da8-9015-1e2d943ad782.png" alt="image.png" class="medium-zoom-image"></p>
<p>3）新建 HTTP 请求<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5633953599181909</span></p>
<p>填写要测试的接口路径、请求类型、请求参数等。</p>
<p>请求参数跟前端进入主页时发送的请求保持一致，如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">json</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-json hljs" data-highlighted="yes"><span class="hljs-punctuation">{</span><span class="hljs-attr">"current"</span><span class="hljs-punctuation">:<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6869005377612754</span></span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"pageSize"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.40096169347881916</span></span><span class="hljs-punctuation">:</span><span class="hljs-number">12</span><span class="hljs-punctuation">,<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3077201283213207</span></span><span class="hljs-attr">"sortField"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"createTime"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6145285019637945</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">"sortOrder"</span><span class="hljs-punctuation">:<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.31503707319130947</span></span><span class="hljs-string">"descend"</span><span class="hljs-punctuation">}</span>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6924676183971712</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.274296634717911</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7353231244664782</span></pre>
<p>配置如图：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/65149084-87c0-4118-81cd-2b6901131cae.png" alt="image.png" class="medium-zoom-image"></p>
<p>4）创建响应断言<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6597732624485888</span></p>
<p>响应断言的作用是判断接口是否正常响应。</p>
<p>此处我们定义的正常响应规则是：响应文本要包含 <code>\"code\":0</code>，否则为异常情况。</p>
<p>配置如图：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4841968338816751</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/97cc430b-e090-4d87-9f8f-d0c06f7b9a8c.png" alt="image.png" class="medium-zoom-image"></p>
<p>5）配置压测结果展示</p>
<p>添加查看结果树、聚合报告：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7743194201813275</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/8192f19d-af16-4864-b03e-677184d286da.png" alt="image.png" class="medium-zoom-image"></p>
<h4 data-id="heading-35">3、压测执行</h4>
<p>做好配置后，右键线程组，点击启动，等待执行即可。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5583989858841694</span></p>
<blockquote>
<p>执行过程中，软件可能会卡顿，因为压测是非常耗费系统资源的。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.012929713130749532</span></blockquote>
<p>执行完成后，查看结果树，能够查看到每次请求的响应结果：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/8553c746-e98f-4c6e-a544-090b881f2edb.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7877189238130642</span></p>
<p>查看聚合报告，这里有我们最需要的数据。</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/9d8ac3a4-07dc-49df-bc53-98e2e08db84f.png" alt="image.png" class="medium-zoom-image"></p>
<p>压测发现，1000 个线程、10 组、10 秒启动、保证 0 异常的前提下，qps（也就是结果中的吞吐量）为 <strong>62.5 / 秒</strong> 。而且因为后端处理能力跟不上请求速度，很多请求需要排队等待十几秒，甚至最大值要等 20 多秒，才能得到响应。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4602851566122874</span></p>
<p>那怎么才能应对大量的并发请求？增加系统的 qps、并且减少请求等待呢？</p>
<h5 data-id="heading-36">小知识：qps 和 tps 的区别</h5>
<p>QPS（Queries Per Second）每秒查询数。 主要用于衡量系统的查询性能，通常在数据库、搜索引擎等场景中使用。每一个查询可以是数据库查询、HTTP请求、网络请求等。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6751232224750363</span></p>
<p>TPS（Transactions Per Second）每秒事务数。主要用于衡量系统的事务处理能力，通常在交易、支付、订单处理等涉及多个步骤的场景中使用。每一个事务可以包括多个操作步骤。</p>
<p>在实际应用中，这两个指标的选择取决于系统的特性和关注点。如果系统主要是处理查询请求，那么 QPS 更合适；如果系统主要是进行复杂的事务处理，那么 TPS 更合适。</p>
<h3>方法四、分布式缓存<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3133938951562447</span></h3>
<p>想要提升数据的查询性能，最有效的办法之一就是 <strong>缓存</strong> 。把数据放到一个读取更快的存储，而不用每次都从数据库查询。</p>
<p>缓存尤其适用于 <strong>读多写少</strong> 的数据，可以最大程度利用缓存、并且减少数据不一致的风险。</p>
<p>对于我们的项目，生成器的修改频率一般是很低的，而且实际运营时，生成器应该是需要人工审核才能展示到主页，所以对数据更新实时性的要求并不高，使用缓存非常合适。而像实时电商数据大屏这种需要持续展示最新数据的场景，用缓存的成本就比较大了。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5358520102519415</span></p>
<p>此处，我们使用主流的、基于内存的分布式缓存 Redis，来存储生成器分页数据，它的读写性能远超 MySQL。</p>
<h4 data-id="heading-38">1、Redis 安装和管理</h4>
<p>首先安装 Redis，Windows 系统的用户可以在编程导航项目网盘中找到安装包，Mac 用户可以直接使用 <code>brew install redis</code> 命令快速安装。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.31426161964931687</span></p>
<p>安装后，启动 Redis：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/38ca799f-1c93-4127-a72e-d9341e0f2a0e.png" alt="image.png" class="medium-zoom-image"></p>
<p>可以使用 IDEA 内置的可视化工具来管理 Redis，如下图：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9680171229729175</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/ce0678db-f4a4-4679-95fa-84477eec7856.png" alt="image.png" class="medium-zoom-image"></p>
<p>填写 Redis 配置：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/b9930ffc-faa6-4c91-ae28-6b5ada636d06.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.32815753842982986</span></p>
<p>然后就能查看 Redis 内的数据了：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/8dbac88d-7b37-4e0b-90e6-7b87a7d553a3.png" alt="image.png" class="medium-zoom-image"></p>
<h4>2、使用缓存<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5004668402599466</span></h4>
<p>1）引入 Redis</p>
<p>web 项目默认已经引入了 Redis 相关的依赖，直接取消 <code>application.yml</code> 配置中 Redis 的注释，开启 Redis。</p>
<p>代码如下：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8869711416998163</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">yaml</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-yaml hljs" data-highlighted="yes"><span class="hljs-attr">spring:</span>
  <span class="hljs-comment"># Redis 配置</span>
  <span class="hljs-attr">redis:<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7895148348726695</span></span>
    <span class="hljs-attr">database:</span> <span class="hljs-number">1</span>
    <span class="hljs-attr">host:<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.051592624030251555</span></span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">6379<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7594333911598732</span></span>
    <span class="hljs-attr">timeout:</span> <span class="hljs-number">5000</span>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5444177820809948</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.20698730272713717</span></pre>
<p>修改 <code>MainApplication</code> 入口类，取消移除 Redis 的代码：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-meta">@SpringBootApplication</span>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8498228193003663</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6084438956414404</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6432026507823951</span></pre>
<p>然后引入 Spring 为我们提供的 StringRedisTemplate 就能操作 Redis 了：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-meta">@Resource</span>
<span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.22083793012502695</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3122170207941086</span></pre>
<p>2）缓存 key 设计。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.09532909794306921</span></p>
<p>先设计缓存的 key，规则为：<code>业务前缀:数据分类:请求参数</code>。</p>
<p>业务前缀和数据分类的作用是为了区分不同业务和接口的缓存，防止冲突。</p>
<p>将请求参数作为 key，就能实现不同的分页查询不同的缓存。需要注意的是，请求参数字符串可能很长，所以我们选用 base64 进行编码。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.927399373390831</span></p>
<p>编写一个方法，用于获取分页缓存 key。代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">/**
 * 获取分页缓存 key
 * <span class="hljs-doctag">@param</span> generatorQueryRequest
 * <span class="hljs-doctag">@return</span>
 */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4962532197645928</span></span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.24800398508803045</span></span> String <span class="hljs-title function_">getPageCacheKey</span><span class="hljs-params">(GeneratorQueryRequest generatorQueryRequest)</span> {
    <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.19253533391495936</span></span> <span class="hljs-variable">jsonStr</span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(generatorQueryRequest);
    <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.21351268543376922</span></span> <span class="hljs-variable">base64</span> <span class="hljs-operator">=</span> Base64Encoder.encode(jsonStr);
    <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.16689552988204914</span></span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">"generator:page:"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9447709237245046</span></span> + base64;
    <span class="hljs-keyword">return</span> key;
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.46452035421325233</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7005447476911644</span></pre>
<p>3）缓存内容设计。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3656753930147332</span></p>
<p>对于分页数据的缓存，可以有如下 2 种策略：</p>
<ol>
<li>缓存整页数据</li>
<li>分页的每条数据单独缓存。查询时先获取到 id 集合，再根据 id 集合去批量查询缓存。</li>
</ol>
<blockquote>
<p>推荐文章：<a href="https://www.zhihu.com/question/264744569/answer/3042972530">https://www.zhihu.com/question/264744569/answer/3042972530</a></p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9645588820228874</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.913280875766082</span></blockquote>
<p>此处我们选择第一种策略，直接缓存接口的返回结果，不仅开发成本更低、性能也更高，但缺点就是不利于分页中某一条数据的更新。</p>
<blockquote>
<p>一般情况下，建议按需缓存，只缓存数据高频访问的情况，以提高缓存的利用率（命中率），比如只缓存首页数据的第一页。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6249603633131826</span></blockquote>
<p>我们先使用 Redis 的 string 数据结构，将分页对象转为 JSON 字符串后写入。相比于 JDK 自带的序列化机制，用 JSON 字符串会使缓存的可读性更好。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.20402923321461386</span></p>
<p>4）应用缓存</p>
<p>改造分页查询接口，优先从缓存读取，如果有缓存，直接读取数据并返回；如果没有缓存，才读取数据库查询数据，并写入缓存。</p>
<p>注意，一定要给缓存设置过期时间！<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.591768293045448</span></p>
<p>完整代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">/**
 * 快速分页获取列表（封装类）
 *
 * <span class="hljs-doctag">@param</span> generatorQueryRequest
 * <span class="hljs-doctag">@param</span> request
 * <span class="hljs-doctag">@return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05070749162327348</span></span>
 */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5867548001933158</span></span>
<span class="hljs-meta">@PostMapping("/list/page/vo/fast")</span>
<span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.34697803953436623</span></span> BaseResponse&lt;Page&lt;GeneratorVO&gt;&gt; <span class="hljs-title function_">listGeneratorVOByPageFast</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> GeneratorQueryRequest generatorQueryRequest,
                                                                 HttpServletRequest request)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6132559519444001</span></span> {
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.34601373818056724</span></span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> generatorQueryRequest.getCurrent();
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5467833651119922</span></span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> generatorQueryRequest.getPageSize();
    <span class="hljs-comment">// 优先从缓存读取<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7108589157237264</span></span>
    <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5097503349924668</span></span> getPageCacheKey(generatorQueryRequest);
    ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();
    <span class="hljs-type">String</span> <span class="hljs-variable">cacheValue</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6397501920629773</span></span> valueOperations.get(cacheKey);
    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(cacheValue)) {
        Page&lt;GeneratorVO&gt; generatorVOPage = JSONUtil.toBean(cacheValue,
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.031487961168501055</span></span>&lt;Page&lt;GeneratorVO&gt;&gt;() {
                },
                <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span> ResultUtils.success(generatorVOPage);
    }

    <span class="hljs-comment">// 限制爬虫<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6251025254893998</span></span>
    ThrowUtils.throwIf(size &gt; <span class="hljs-number">20</span>, ErrorCode.PARAMS_ERROR);
    Page&lt;Generator&gt; generatorPage = generatorService.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.1647602925746654</span></span>&lt;&gt;(current, size),
            generatorService.getQueryWrapper(generatorQueryRequest));
    Page&lt;GeneratorVO&gt; generatorVOPage = generatorService.getGeneratorVOPage(generatorPage, request);
    generatorVOPage.getRecords().forEach(generatorVO -&gt; {
        generatorVO.setFileConfig(<span class="hljs-literal">null</span>);
        generatorVO.setModelConfig(<span class="hljs-literal">null</span>);
    });

    <span class="hljs-comment">// 写入缓存<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3153440777989951</span></span>
    valueOperations.set(cacheKey, JSONUtil.toJsonStr(generatorVOPage), <span class="hljs-number">100</span>, TimeUnit.MINUTES);
    <span class="hljs-keyword">return</span> ResultUtils.success(generatorVOPage);
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8744056241255547</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.29345904681590196</span></pre>
<p>5）简单测试<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.04111438247785082</span></p>
<p>访问接口后，可以在 Redis 中查看到缓存的信息：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/acdf1b32-8da9-416f-9eac-73b11232c302.png" alt="image.png" class="medium-zoom-image"></p>
<p>可以在 Redis 控制台中使用 <code>ttl</code> 命令查看过期时间，单位为秒：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6103336541034832</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/06707f4f-97b7-4cc3-bcf1-730a76d1c184.png" alt="image.png" class="medium-zoom-image"></p>
<h4 data-id="heading-40">3、测试</h4>
<p>先在浏览器内进行测试，访问主页，然后打开网页控制台查看请求。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.16956373947396775</span></p>
<p>测试发现，使用缓存后，响应时间大幅减少，平均耗时 40 毫秒，缩短了 80%！</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/7b3c93fb-d942-4fa5-8961-db335c981f99.png" alt="image.png" class="medium-zoom-image"></p>
<p>接下来进行压力测试，首先构建缓存。然后用之前的线程组配置（1000 个线程、10 组、10 秒启动），保证 0 异常的前提下，qps 达到 200.8 / 秒，已经是之前的 <strong>3 倍</strong> 了！<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9389996860195982</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/ad1eb124-5a4e-4d35-a1d1-1c871811eedb.png" alt="image.png" class="medium-zoom-image"></p>
<p>但是因为系统处理能力还是跟不上请求速度，很多线程需要排队等待 4 秒，最大值要等 7 多秒。所以我们还需要再进一步优化。</p>
<h3>方法五、多级缓存<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7496123783862068</span></h3>
<p>如果 Redis 缓存还不够快，我们还可以使用本地缓存，直接从内存中读取缓存、不需要任何网络请求，一般能得到进一步的性能提升。</p>
<h4 data-id="heading-42">1、Caffeine 本地缓存</h4>
<p>要想在 Java 中使用本地缓存，推荐使用 Caffeine 库，这是一个主流的、高性能的本地缓存库。相比于自己构造 HashMap，Caffeine 还支持多种数据淘汰、数据通知、异步刷新等能力，更易用。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9959404102719758</span></p>
<p>想入门 Caffeine 这种类库，最好的方式还是阅读官方文档。</p>
<p>Caffeine 官网：<a href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p>
<p>中文教程：<a href="https://github.com/ben-manes/caffeine/wiki/Home-zh-CN">https://github.com/ben-manes/caffeine/wiki/Home-zh-CN</a><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4813430580143703</span></p>
<p>从这里开始：<a href="https://github.com/ben-manes/caffeine/wiki/Population-zh-CN">https://github.com/ben-manes/caffeine/wiki/Population-zh-CN</a></p>
<blockquote>
<p>注意，根据官方文档，Caffeine 3 版本需要 Java 11 或以上，Java 8 请用 Caffeine 2 版本！</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6466930062766896</span></blockquote>
<p>其实非常简单，几行代码就能实现缓存的增删改查：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.14429461689168965</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes">Cache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()
    .expireAfterWrite(<span class="hljs-number">10</span>, TimeUnit.MINUTES)
    .maximumSize(<span class="hljs-number">10_000</span>)
    .build();

<span class="hljs-comment">// 查找一个缓存元素， 没有查找到的时候返回null<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5151129017684</span></span>
<span class="hljs-type">Graph</span> <span class="hljs-variable">graph</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.20996072054995008</span></span> cache.getIfPresent(key);
<span class="hljs-comment">// 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null</span>
graph = cache.get(key, k -&gt; createExpensiveGraph(key));
<span class="hljs-comment">// 添加或者更新一个缓存元素</span>
cache.put(key, graph);
<span class="hljs-comment">// 移除一个缓存元素<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.35986696661333073</span></span>
cache.invalidate(key);
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5956413234920788</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18283446864311048</span></pre>
<h4 data-id="heading-43">2、多级缓存设计</h4>
<p>对于分布式系统，我们一般不会单独使用本地缓存，而是将本地缓存和分布式缓存进行组合，形成多级缓存。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0453185299521377</span></p>
<p>就以 Caffeine 和 Redis 为例，通常用 Caffeine 作为一级缓存，Redis 作为二级缓存。</p>
<p>1）Caffeine 一级缓存：将数据存储在应用程序的内存中，性能更高。但是仅在本地生效，而且应用程序关闭后，数据会丢失。</p>
<p>2）Redis 二级缓存：将数据存储在 Redis 中，所有的程序都从 Redis 内读取数据，可以实现数据的持久化和缓存的共享。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6673892724282751</span></p>
<p>二者结合，请求数据时，首先查找本地一级缓存；如果在本地缓存中没有查询到数据，再查找远程二级缓存，并且写入到本地缓存；如果还没有数据，才从数据库中读取，并且写入到所有缓存。</p>
<p>使用多级缓存，可以充分利用本地缓存的快速读取特性，以及远程缓存的共享和持久化特性。</p>
<h4>3、多级缓存开发<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7544041128768089</span></h4>
<p>首先在 <code>manager</code> 包下新建一个通用的多级缓存类 <code>CacheManager</code>，并分别编写读取缓存、写入缓存、清理缓存的方法。</p>
<p>完整代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">package</span> com.yupi.web.manager;

<span class="hljs-keyword">import</span> com.github.benmanes.caffeine.cache.Cache;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.026529453880766107</span></span> com.github.benmanes.caffeine.cache.Caffeine;
<span class="hljs-keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9439008371459174</span></span> javax.annotation.Resource;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**
 * 多级缓存
 */</span>
<span class="hljs-meta">@Component<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6540937796727735</span></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheManager<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6001838219604156</span></span> {

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;

    <span class="hljs-comment">// 本地缓存<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6373284598539561</span></span>
    Cache&lt;String, String&gt; localCache = Caffeine.newBuilder()
            .expireAfterWrite(<span class="hljs-number">100</span>, TimeUnit.MINUTES)
            .maximumSize(<span class="hljs-number">10_000</span>)
            .build();

    <span class="hljs-comment">/**
     * 写缓存
     *
     * <span class="hljs-doctag">@param</span> key
     * <span class="hljs-doctag">@param</span> value
     */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5821646077291729</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.401166834223758</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9040480949145722</span></span><span class="hljs-params">(String key, String value)</span> {
        localCache.put(key, value);
        stringRedisTemplate.opsForValue().set(key, value, <span class="hljs-number">100</span>, TimeUnit.MINUTES);
    }

    <span class="hljs-comment">/**
     * 读缓存
     *
     * <span class="hljs-doctag">@param</span> key
     * <span class="hljs-doctag">@return</span>
     */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5198998473443077</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.04428558476848754</span></span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6349328964803762</span></span> {
        <span class="hljs-comment">// 先从本地缓存中尝试获取</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">value<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.43186673862919456</span></span> <span class="hljs-operator">=</span> localCache.getIfPresent(key);
        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8299294823991941</span></span>) {
            <span class="hljs-keyword">return</span> value;
        }

        <span class="hljs-comment">// 本地缓存未命中，尝试从 Redis 中获取</span>
        value = stringRedisTemplate.opsForValue().get(key);
        <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.10841412899351388</span></span> (value != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 将从 Redis 获取的值放入本地缓存</span>
            localCache.put(key, value);
        }

        <span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2157423461571948</span></span> value;
    }

    <span class="hljs-comment">/**
     * 移除缓存
     *
     * <span class="hljs-doctag">@param</span> key
     */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.42356243756765544</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.989629703595764</span></span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String key)</span> {
        localCache.invalidate(key);
        stringRedisTemplate.delete(key);
    }
}

<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9158191641548579</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.862787212778241</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.07172316471941831</span></pre>
<p>然后就可以在查询接口中使用多级缓存，代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">/**
 * 快速分页获取列表（封装类）
 *
 * <span class="hljs-doctag">@param</span> generatorQueryRequest
 * <span class="hljs-doctag">@param</span> request
 * <span class="hljs-doctag">@return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3619552467672682</span></span>
 */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7690832278819457</span></span>
<span class="hljs-meta">@PostMapping("/list/page/vo/fast")</span>
<span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3608531673292641</span></span> BaseResponse&lt;Page&lt;GeneratorVO&gt;&gt; <span class="hljs-title function_">listGeneratorVOByPageFast</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> GeneratorQueryRequest generatorQueryRequest,
                                                                 HttpServletRequest request)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.32601253117223905</span></span> {
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3209711747449264</span></span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> generatorQueryRequest.getCurrent();
    <span class="hljs-type">long<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.14179016886004736</span></span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> generatorQueryRequest.getPageSize();
    <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4756269527824615</span></span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getPageCacheKey(generatorQueryRequest);

    <span class="hljs-comment">// 多级缓存<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.03550259237897624</span></span>
    <span class="hljs-type">String</span> <span class="hljs-variable">cacheValue</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.036527094223715695</span></span> cacheManager.get(cacheKey);
    <span class="hljs-keyword">if</span> (cacheValue != <span class="hljs-literal">null</span>) {
        Page&lt;GeneratorVO&gt; generatorVOPage = JSONUtil.toBean(cacheValue,
                <span class="hljs-keyword">new<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6769502968599648</span></span> <span class="hljs-title class_">TypeReference</span>&lt;Page&lt;GeneratorVO&gt;&gt;() {
                },
                <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.1634214584499074</span></span> ResultUtils.success(generatorVOPage);
    }

    <span class="hljs-comment">// 限制爬虫</span>
    ThrowUtils.throwIf(size &gt; <span class="hljs-number">20</span>, ErrorCode.PARAMS_ERROR);
    QueryWrapper&lt;Generator&gt; queryWrapper = generatorService.getQueryWrapper(generatorQueryRequest);
    queryWrapper.select(<span class="hljs-string">"id"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.38130961592221824</span></span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"description"</span>, <span class="hljs-string">"tags"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.20871859656253422</span></span>, <span class="hljs-string">"picture"</span>, <span class="hljs-string">"status"</span>, <span class="hljs-string">"userId"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7675487476174991</span></span>, <span class="hljs-string">"createTime"</span>, <span class="hljs-string">"updateTime"</span>);
    Page&lt;Generator&gt; generatorPage = generatorService.page(<span class="hljs-keyword">new<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.054417012722713265</span></span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, size), queryWrapper);
    Page&lt;GeneratorVO&gt; generatorVOPage = generatorService.getGeneratorVOPage(generatorPage, request);

    <span class="hljs-comment">// 写入多级缓存</span>
    cacheManager.put(cacheKey, JSONUtil.toJsonStr(generatorVOPage));
    <span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.563776534872166</span></span> ResultUtils.success(generatorVOPage);
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.21078972584856204</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.27647515095901976</span></pre>
<h4>4、测试<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7688004194892031</span></h4>
<p>先在浏览器内简单测试。</p>
<p>测试发现，使用本地缓存后，响应时间进一步减少，平均 30 毫秒，缩短了 25%。</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/7d262f29-4bbf-4ef6-8a31-fc0e118a9f5b.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.13574820303617652</span></p>
<p>接下来进行压力测试，首先构建本地缓存。然后用之前的线程组配置（1000 个线程、10 组、10 秒启动），保证 0 异常的前提下，qps 达到 208.8 / 秒。</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/18454bb3-f6fa-4d41-a637-43776ce8f18e.png" alt="image.png" class="medium-zoom-image"></p>
<p>咦，为什么性能没有明显的提升呢？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3965586135815655</span></p>
<p>几个猜测：</p>
<ol>
<li>由于 Redis 也在本地，所以性能提升并不明显。</li>
<li>直接读取本地已经是最快的读取方法了，也许系统存在其他的性能瓶颈？</li>
</ol>
<p>那怎么才能进一步提升 qps 呢？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.16599400329589264</span></p>
<p>既然读取数据（IO）无法继续优化了，那我们可以尝试优化计算。</p>
<h3 data-id="heading-46">方法六、计算优化</h3>
<h4>1、分析<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5942468456248724</span></h4>
<p>任何计算都会消耗系统的 CPU 资源，在 CPU 资源有限的情况下，我们能做的就是 <strong>减少不必要的计算</strong> 。</p>
<p>分析我们的代码，基本上没有循环计算逻辑，可能消耗计算资源的操作应该就是 JSON 序列化（反序列化）。</p>
<blockquote>
<p>在 JSON 序列化中，需要遍历数据结构并将其转换为 JSON 格式的字符串。这个过程中可能涉及到字符串拼接、字符编码转换等计算密集型操作。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.20374113622189727</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5749147232366227</span></blockquote>
<p>之前是为了更直观地查看缓存数据，才将对象序列化为 JSON 后写入缓存，现在为了提高性能，我们可以直接用 JDK 默认的序列化工具读写缓存。</p>
<h4 data-id="heading-48">2、开发</h4>
<p>1）首先修改 maker 项目中，Meta 对象的所有子类，给它们都添加序列化支持。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7396344069220566</span></p>
<p>比如：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.39868532323204375</span></span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileConfig<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2282138169492074</span></span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> {
    <span class="hljs-keyword">private<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.600066515562268</span></span> String inputRootPath;
    <span class="hljs-keyword">private</span> String outputRootPath;
    <span class="hljs-keyword">private</span> String sourceRootPath;
    <span class="hljs-keyword">private<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.28900431564706963</span></span> String type;
    <span class="hljs-keyword">private</span> List&lt;FileInfo&gt; files;

    <span class="hljs-meta">@NoArgsConstructor</span>
    <span class="hljs-meta">@Data<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.26968796058639066</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6572917274646233</span></span> <span class="hljs-title class_">FileInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3460251939749064</span></span> {
        <span class="hljs-keyword">private</span> String inputPath;
        <span class="hljs-keyword">private</span> String outputPath;
        <span class="hljs-keyword">private<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7841428781042634</span></span> String type;
        <span class="hljs-keyword">private</span> String generateType;
        <span class="hljs-keyword">private</span> String condition;
        <span class="hljs-keyword">private<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0984671754374642</span></span> String groupKey;
        <span class="hljs-keyword">private</span> String groupName;
        <span class="hljs-keyword">private</span> List&lt;FileInfo&gt; files;
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.11073866445510316</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6176683532151388</span></pre>
<p>2）修改 <code>CacheManager</code>，将缓存类型从 String 改为 Object。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2866100784587826</span></p>
<p>代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">package</span> com.yupi.web.manager;

<span class="hljs-keyword">import</span> com.github.benmanes.caffeine.cache.Cache;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3577986347204676</span></span> com.github.benmanes.caffeine.cache.Caffeine;
<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.07917553742094396</span></span> javax.annotation.Resource;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**
 * 多级缓存
 */</span>
<span class="hljs-meta">@Component<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.40165795807706894</span></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheManager<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2446148749604229</span></span> {

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;

    <span class="hljs-comment">// 本地缓存<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.48254527326958385</span></span>
    Cache&lt;String, Object&gt; localCache = Caffeine.newBuilder()
            .expireAfterWrite(<span class="hljs-number">100</span>, TimeUnit.MINUTES)
            .maximumSize(<span class="hljs-number">10_000</span>)
            .build();

    <span class="hljs-comment">/**
     * 写缓存
     *
     * <span class="hljs-doctag">@param</span> key
     * <span class="hljs-doctag">@param</span> value
     */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2997690484235871</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6344079474750468</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05092238069560806</span></span><span class="hljs-params">(String key, Object value)</span> {
        localCache.put(key, value);
        redisTemplate.opsForValue().set(key, value, <span class="hljs-number">100</span>, TimeUnit.MINUTES);
    }

    <span class="hljs-comment">/**
     * 读缓存
     *
     * <span class="hljs-doctag">@param</span> key
     * <span class="hljs-doctag">@return</span>
     */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5617839250207133</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6913283104705148</span></span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String key)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9514035939442209</span></span> {
        <span class="hljs-comment">// 先从本地缓存中尝试获取</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">value<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.688928598145975</span></span> <span class="hljs-operator">=</span> localCache.getIfPresent(key);
        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8915061540523008</span></span>) {
            <span class="hljs-keyword">return</span> value;
        }

        <span class="hljs-comment">// 本地缓存未命中，尝试从 Redis 中获取</span>
        value = redisTemplate.opsForValue().get(key);
        <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0781792702173627</span></span> (value != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 将从 Redis 获取的值放入本地缓存</span>
            localCache.put(key, value);
        }

        <span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.49967426798126824</span></span> value;
    }

    <span class="hljs-comment">/**
     * 移除缓存
     *
     * <span class="hljs-doctag">@param</span> key
     */<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8368224789462817</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8788080556161912</span></span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String key)</span> {
        localCache.invalidate(key);
        redisTemplate.delete(key);
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7664027733580197</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8866672155396982</span></pre>
<p>3）修改查询接口，移除序列化相关的代码。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7967275368103037</span></p>
<p>代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-meta">@PostMapping("/list/page/vo/fast")</span>
<span class="hljs-keyword">public</span> BaseResponse&lt;Page&lt;GeneratorVO&gt;&gt; <span class="hljs-title function_">listGeneratorVOByPageFast<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.40198648622524424</span></span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> GeneratorQueryRequest generatorQueryRequest,
                                                                 HttpServletRequest request)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8501374549514624</span></span> {
    <span class="hljs-type">long</span> <span class="hljs-variable">current<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3702460385432287</span></span> <span class="hljs-operator">=</span> generatorQueryRequest.getCurrent();
    <span class="hljs-type">long</span> <span class="hljs-variable">size<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6263305131535304</span></span> <span class="hljs-operator">=</span> generatorQueryRequest.getPageSize();
    <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7640281007777827</span></span> <span class="hljs-operator">=</span> getPageCacheKey(generatorQueryRequest);

    <span class="hljs-comment">// 本地缓存</span>
    <span class="hljs-type">Object<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.02726309244995062</span></span> <span class="hljs-variable">cacheValue</span> <span class="hljs-operator">=</span> cacheManager.get(cacheKey);
    <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5895167978144302</span></span> (cacheValue != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> ResultUtils.success((Page&lt;GeneratorVO&gt;) cacheValue);
    }

    <span class="hljs-comment">// 限制爬虫<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2640017063930733</span></span>
    ThrowUtils.throwIf(size &gt; <span class="hljs-number">20</span>, ErrorCode.PARAMS_ERROR);
    QueryWrapper&lt;Generator&gt; queryWrapper = generatorService.getQueryWrapper(generatorQueryRequest);
    queryWrapper.select(<span class="hljs-string">"id"</span>, <span class="hljs-string">"name"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5668422302186906</span></span>, <span class="hljs-string">"description"</span>, <span class="hljs-string">"tags"</span>, <span class="hljs-string">"picture"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3541927971619383</span></span>, <span class="hljs-string">"status"</span>, <span class="hljs-string">"userId"</span>, <span class="hljs-string">"createTime"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0011520143523977566</span></span>, <span class="hljs-string">"updateTime"</span>);
    Page&lt;Generator&gt; generatorPage = generatorService.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5631112804680667</span></span>&lt;&gt;(current, size), queryWrapper);
    Page&lt;GeneratorVO&gt; generatorVOPage = generatorService.getGeneratorVOPage(generatorPage, request);

    <span class="hljs-comment">// 写入本地缓存</span>
    cacheManager.put(cacheKey, generatorVOPage);
    <span class="hljs-keyword">return</span> ResultUtils.success(generatorVOPage);
}

<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3916863952693508</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.059807794285465565</span></pre>
<h4>3、测试<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.30139408879598517</span></h4>
<p>移除序列化后，再次使用同样的线程组配置进行压测。</p>
<p>结果性能得到了大幅优化，qps 达到了 1000 多， 提升了 5 倍左右！</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/8d4ea63f-272f-4c57-ac3b-affd565a9c9e.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4462174993150816</span></p>
<p>注意，由于 1000 qps 已经超过了我们之前设置的压测线程生成速率，结果可能不准。所以更改线程组配置，将循环次数扩大为 100，相当于每秒创建 1 万个线程测试。</p>
<p>如图：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/113c2b93-8b39-4431-9819-7136e3e33e18.png" alt="image.png" class="medium-zoom-image"><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4371506352806862</span></p>
<p>再次压测，这次 qps 达到了 2000，是最开始做任何优化前的 30 倍！</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/9d525bad-b47d-45d2-9b99-f2e68e66deb4.png" alt="image.png" class="medium-zoom-image"></p>
<p>OK，目前的查询接口性能已经能够满足大多数并发诉求了，但如果想进一步优化，需要怎么做呢？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5111979986823214</span></p>
<p>当然还有方法。注意，以下仅分享优化思路，是否能进一步提升性能，要以实际测试为准。</p>
<h3 data-id="heading-50">方法七、请求层性能优化</h3>
<h4>1、参数优化<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8643325792806227</span></h4>
<p>分析上述测试结果，当并发请求数量超出系统处理能力时，会出现请求排队，而且请求排队最大时间长达 8 秒。</p>
<p>怎么能解决这个问题呢？</p>
<p>用生活场景来类比。就跟去快餐店一样，如果服务员不够了，只要增加工作人员的数量，就能同时服务更多顾客。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4567138158929889</span></p>
<p>而如果餐厅备菜的速度足够快，可以增加排队的最大容量，起码业务繁忙时不用把顾客赶出去。</p>
<p>回到我们的后端系统，如果业务逻辑层很难进一步优化，可以尝试优化请求层。</p>
<p>比如 Spring Boot 项目默认使用嵌入式的 Tomcat 服务器接受处理请求，可以调整 tomcat 的参数，比如最大线程数 maxThreads、最大连接数 maxConnections、请求队列长度 accept-count 等，来增加同时接受处理请求的能力。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.712507739563824</span></p>
<p>比如：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">yaml</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-yaml hljs" data-highlighted="yes"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">tomcat:</span>
    <span class="hljs-attr">threads:<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8254156729809923</span></span>
      <span class="hljs-attr">max:</span> <span class="hljs-number">1024</span>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7877027847265863</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6188837722339835</span></pre>
<blockquote>
<p>推荐文章：<a href="https://www.cnblogs.com/javastack/p/17756325.html">https://www.cnblogs.com/javastack/p/17756325.html</a></p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9649442350165196</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5446977239220812</span></blockquote>
<p>更改上述配置后进行压力测试，发现 qps 达到了 3700，性能又提升了接近 1 倍，是最初的 60 倍！</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/495b4a9e-33ff-4033-92e8-724f72eaec80.png" alt="image.png" class="medium-zoom-image"></p>
<p>需要注意，更高的最大线程数设置未必能提升 qps。因为在 CPU 资源有限的情况下，线程数过多可能导致资源的竞争和上下文的频繁切换。所以最大线程数设置为多少，取决于实际的性能测试。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6672236530208004</span></p>
<p>思考：qps 还能进一步优化么？或者说，我们优化的极限到底在哪里？如何得到这个极限呢？</p>
<h4 data-id="heading-52">2、测试空接口性能</h4>
<p>可以编写一个干净的、没有任何业务逻辑的接口，然后测试 Tomcat 服务器处理请求的最大性能。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9976561480419974</span></p>
<p>1）编写一个干净的接口</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-comment">/**
 * 健康检查
 */</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/health")<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5249918439171264</span></span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3366514827253757</span></span> <span class="hljs-title class_">HealthController</span> {

    <span class="hljs-meta">@GetMapping</span>
    <span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.15397011820808548</span></span> String <span class="hljs-title function_">healthCheck</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6854885659273176</span></span> <span class="hljs-string">"ok"</span>;
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5095424284932013</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7976320505130743</span></pre>
<p>2）注释掉请求拦截器，防止额外的处理逻辑干扰测试结果：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.38728748783564715</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/d88a8e98-f1f5-4427-b440-a315579df04d.png" alt="image.png" class="medium-zoom-image"></p>
<p>3）测试</p>
<p>新增一个线程组来压力测试，修改测试接口地址为 <code>/health</code>，使用之前的线程组配置（1000 个线程、100 组、10 秒启动）。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.537311705681168</span></p>
<p>测试发现，空接口的 qps 最高能到 6500 左右。</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/6df54a27-cc13-43e5-8c03-4f56addbddab.png" alt="image.png" class="medium-zoom-image"></p>
<p>在我的电脑环境下，这可能就是一个接近极限的数字，说明无论我们再怎么优化业务逻辑，qps 也不会超过这个值。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.11694180559351075</span></p>
<p>那么如何打破这个极限呢？</p>
<h4 data-id="heading-53">3、Vert.x 反应式编程</h4>
<p>如果接受请求的服务器性能有限，那我们就尝试更换一个性能更高的服务器（或者请求处理框架），比如基于反应式编程的 Vert.x。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.555517089707247</span></p>
<p>为什么选择它呢？首先它是基于 Java 的。另外，在 techempower 最新的压力测试排行榜上，我们发现 Vert.x 这个框架的排名高达第 7 名！</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/903b6318-3059-4d04-bc35-266c227504cc.png" alt="image.png" class="medium-zoom-image"></p>
<p>而 Spring 排名是第 88 名，Vert.x 甩了 Spring 几条街。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5045790760594442</span></p>
<p>不过，这只是别人的测试结果，使用 Vert.x 真的能够提高我们接口的性能么？还是要以实际测试为准。</p>
<h5 data-id="heading-54">Vert.x 入门</h5>
<p>首先通过 <a href="https://vertx.io/">官方文档</a> 了解 Vert.x，据官方介绍，Vert.x 的优点在于：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4917061864293071</span></p>
<ol>
<li>充分利用资源节约成本</li>
<li>更方便的并发和异步编程</li>
<li>使用更灵活，易于整合、启动和部署<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.46597177326839057</span></li>
</ol>
<p>想入门 Vert.x，首先阅读官方的入门教程：<a href="https://vertx.io/get-started/">https://vertx.io/get-started/</a>，提供了示例 Demo。</p>
<p>不过 Vert.x 的学习成本是比较高的，官方文档写的一般，而且入门教程页面都存在问题，所以建议还是以鱼皮的教程为主。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5058978251965531</span></p>
<p>1）先引入依赖：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">xml</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-xml hljs" data-highlighted="yes"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.vertx/vertx-core --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.0019826737595431965</span></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5266862861668529</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8731081903993183</span></span>io.vertx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.48514367890790266</span></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6554197093930951</span></span>vertx-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8217285916459041</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05073862960914299</span></span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8000047292671977</span></span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.12439797814433895</span></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7885952121371114</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.654824786635972</span></span>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3027104579256754</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5723526944905724</span></pre>
<p>2）写一个 Web 服务器，提供 Http 接口。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.90330774033807</span></p>
<p>在 Vert.x 中，可以通过定义 Verticle 来实现 Web 服务。Verticle 是 Vert.x 中的一个组件，用于处理事件、执行业务逻辑，并能够在 Vert.x 实例中进行水平扩展，Verticle 之间可以相互通讯。</p>
<blockquote>
<p>为了便于理解，你可以把它当成一个嵌入式的 Tomcat。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8057772586380352</span></blockquote>
<p>参考官方的 Demo，写一个简单的 Verticle，提供无业务逻辑的接口并响应 “ok”。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9292947969480638</span></p>
<p>代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">package</span> com.yupi.web;

<span class="hljs-keyword">import</span> io.vertx.core.AbstractVerticle;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8645849284182785</span></span> io.vertx.core.Verticle;
<span class="hljs-keyword">import</span> io.vertx.core.Vertx;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8362093392158612</span></span> <span class="hljs-title class_">MainVerticle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractVerticle<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3688573041759722</span></span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.19638141721036995</span></span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.822126000358457</span></span> Exception {
        <span class="hljs-comment">// Create the HTTP server</span>
        vertx.createHttpServer()
                <span class="hljs-comment">// Handle every request using the router</span>
                .requestHandler(req -&gt; {
                    req.response()
                            .putHeader(<span class="hljs-string">"content-type"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.10021292864833109</span></span>, <span class="hljs-string">"text/plain"</span>)
                            .end(<span class="hljs-string">"ok"</span>);
                })
                <span class="hljs-comment">// Start listening<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.24448382355203457</span></span>
                .listen(<span class="hljs-number">8888</span>)
                <span class="hljs-comment">// Print the port</span>
                .onSuccess(server -&gt;
                        System.out.println(
                                <span class="hljs-string">"HTTP server started on port "<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.30499141343541214</span></span> + server.actualPort()
                        )
                );
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6951988644380187</span></span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5666046658990944</span></span> Exception {
        <span class="hljs-type">Vertx</span> <span class="hljs-variable">vertx</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7712979193426774</span></span> Vertx.vertx();
        <span class="hljs-type">Verticle</span> <span class="hljs-variable">myVerticle</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9648409646492577</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainVerticle</span>();
        vertx.deployVerticle(myVerticle);
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.31643262349563095</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5009957122974258</span></pre>
<p>当然，如果感兴趣的话，也可以尝试使用 Vert.x web 组件开发接口，有点类似 Node.js 后端框架的语法。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3768433723394211</span></p>
<p>参考代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">import</span> io.vertx.core.AbstractVerticle;
<span class="hljs-keyword">import</span> io.vertx.core.Future;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.40808037013732945</span></span> io.vertx.core.http.HttpServer;
<span class="hljs-keyword">import</span> io.vertx.core.http.HttpServerRequest;
<span class="hljs-keyword">import</span> io.vertx.ext.web.Router;

<span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.42929707486829494</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVerticle</span> <span class="hljs-keyword">extends<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9075291071827414</span></span> <span class="hljs-title class_">AbstractVerticle</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.06692917113785635</span></span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(Future&lt;Void&gt; startFuture)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5113945582910071</span></span> {
        <span class="hljs-comment">// Create an HTTP server</span>
        <span class="hljs-type">HttpServer</span> <span class="hljs-variable">server<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.48711048787579436</span></span> <span class="hljs-operator">=</span> vertx.createHttpServer();

        <span class="hljs-comment">// Create a router to handle requests</span>
        <span class="hljs-type">Router<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.320876559470074</span></span> <span class="hljs-variable">router</span> <span class="hljs-operator">=</span> Router.router(vertx);

        <span class="hljs-comment">// Define a route that handles GET requests to "/hello"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8672529387184527</span></span>
        router.get(<span class="hljs-string">"/hello"</span>).handler(<span class="hljs-built_in">this</span>::handleHello);

        <span class="hljs-comment">// Set the router as the request handler for the server<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.14253183098492017</span></span>
        server.requestHandler(router);

        <span class="hljs-comment">// Listen on port 8080</span>
        server.listen(<span class="hljs-number">8080</span>, ar -&gt; {
            <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.16528508819621468</span></span> (ar.succeeded()) {
                System.out.println(<span class="hljs-string">"Server started on port 8080"</span>);
                startFuture.complete();
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"Failed to start server"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.462677296423714</span></span>);
                startFuture.fail(ar.cause());
            }
        });
    }

    <span class="hljs-comment">// Handler method for the "/hello" route</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6732076334108166</span></span> <span class="hljs-title function_">handleHello</span><span class="hljs-params">(HttpServerRequest request)</span> {
        <span class="hljs-comment">// Respond with a "Hello, Vert.x!" message<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.48151536350209345</span></span>
        request.response()
            .putHeader(<span class="hljs-string">"content-type"</span>, <span class="hljs-string">"text/plain"</span>)
            .end(<span class="hljs-string">"Hello, Vert.x!"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.46831114633929216</span></span>);
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8983182059599293</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7988185114082429</span></pre>
<p>3）用同样的线程组压力测试（1000 个线程、100 组、10 秒启动），发现 Vert.x 的空接口 qps 高达 1 万多！<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.81354378018986</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/e6022918-331b-4077-81ce-aa20904809a9.png" alt="image.png" class="medium-zoom-image"></p>
<p>说明 Vert.x 的极限性能是高于 Tomcat 的。</p>
<h5>Vert.x 为什么快？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.38379851079740157</span></h5>
<p>官方文档中，有很多关于 Vert.x 特性和原理的讲解，比如：</p>
<ul>
<li>链式调用：<a href="https://vertx.io/docs/vertx-core/java/#_are_you_fluent">https://vertx.io/docs/vertx-core/java/#_are_you_fluent</a></li>
<li>异步非阻塞：<a href="https://vertx.io/docs/vertx-core/java/#_dont_block_me">https://vertx.io/docs/vertx-core/java/#_dont_block_me</a></li>
<li>反应式编程：<a href="https://vertx.io/docs/vertx-core/java/#_reactor_and_multi_reactor">https://vertx.io/docs/vertx-core/java/#_reactor_and_multi_reactor</a><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.07552659455594668</span></li>
<li>事件总线：<a href="https://vertx.io/docs/vertx-core/java/#event_bus">https://vertx.io/docs/vertx-core/java/#event_bus</a></li>
</ul>
<p>那 Vert.x 到底为什么快呢？这里讲几个重点概念，讲完大家就清楚了。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.49118793600688027</span></p>
<h6 data-id="heading-56">1）异步非阻塞</h6>
<p>很多经典面试题都是围绕这个概念展开的，比如：</p>
<ul>
<li>什么是同步和异步？</li>
<li>什么是阻塞和非阻塞？</li>
<li>什么是异步非阻塞？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.39202440282732165</span></li>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2883022204840149</span></ul>
<p>下面依次回答。</p>
<p>同步：一个任务的完成需要等待另一个任务的结果。必须按照顺序，先完成上一个任务，才能执行下一个任务。</p>
<p>比如下面的代码：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05999280642979099</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.03292829139413733</span></span> httpClient.get();
System.out.println(result);
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7031916977817012</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.23136466633702435</span></pre>
<p>在通过 http 请求获取到结果后，才会输出，这就是同步执行。</p>
<p>异步：一个任务的完成不需要等待另一个任务的结果。比如我要先烧一壶水、再去学编程，按下烧水按钮后，不需要干瞪眼等水烧好，可以直接去学编程了。异步通常会涉及回调、事件通知机制，比如水烧好后会有响声，提醒我们水已经烧好，我们就可以取水了。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.009664385609776005</span></p>
<p>比如下面的代码：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes">CompletableFuture&lt;Result&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    <span class="hljs-comment">// 异步操作，例如发起 HTTP 请求</span>
    <span class="hljs-keyword">return</span> httpClient.get();
});

System.out.println(<span class="hljs-string">"请求没完成，我也能执行"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5835532072949428</span></span>);

<span class="hljs-comment">// 等请求完成，自动输出</span>
resultFuture.thenAccept(result -&gt; {
    System.out.println(result);
});
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9001537028197164</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.41193978645656926</span></pre>
<p>即使 HTTP 请求每完成，也会先输出 "请求没完成，我也能执行"；而当请求完成后，会自动输出结果。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.20515779014162683</span></p>
<hr>
<p>阻塞：执行一个任务时，需要一直等待，期间无法执行其他任务，直到执行完成。</p>
<p>比如下面的代码：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5692179428271098</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes">request() {
    <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4063905372972316</span></span> db.query();
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.942881234102013</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4410080713438018</span></pre>
<p>直到数据库返回结果前，当前线程会一直卡在 request 方法，不能处理其他任务。</p>
<p>非阻塞：执行一个任务时，不需要等待，可以继续执行其他任务。然后通过定时的检查来确认任务是否完成，也就是所谓的轮询。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.1421720669835631</span></p>
<p>用一个例子来区分阻塞和非阻塞。比如我要通过电话联系某人。如果是阻塞方式，只要对方不接电话，我就一直拿电话等着，不能再给其他人打电话。如果是非阻塞方式，我可以每隔 10 分钟打一次电话，这期间即使对方不在，我也能继续给别人打电话，直到最后打通。</p>
<hr>
<p>同步 / 异步、阻塞 / 非阻塞之间有什么区别呢？<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.703421708427423</span></p>
<p>网上众说纷纭，这里分享我个人比较喜欢的一种解释：</p>
<ul>
<li>同步 / 异步更关注 <strong>消息通信机制</strong> ，即调用方以什么方式获取到结果，是直接返回、还是通过回调通知。</li>
<li>阻塞 / 非阻塞更关注线程在等待调用结果时的状态。如果是阻塞，会一直占用线程资源；而如果是非阻塞，发起调用后可以立即返回，线程可以被解放出来做其他的工作。</li>
</ul>
<hr>
<p>异步非阻塞就是结合了异步和非阻塞的优点，在执行操作时即使没有得到结果，也不会阻塞当前线程、可以继续执行下一个操作；并且得到结果后会通过回调等方式通知程序处理结果。</p>
<p>还有一个常用概念是 NIO（非阻塞 I/O），是 Java 提供的一组支持非阻塞 I/O 操作的 API，通过通道、缓冲区、选择器等组件，实现了一个线程同时处理多个通道请求的能力；并且实现了事件驱动机制，当通道有事件发生时，通过选择器响应，而不是轮询所有的通道。</p>
<p>如下图：通过 Selector，可以复用一个线程处理多个 Channel（客户端连接）。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9605022340980178</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/2e41f37b-0315-4407-b2ce-7f144198a407.png" alt="image.png" class="medium-zoom-image"></p>
<p>举个生活中的例子，要收整个班级的作业，不用让老师一个一个学生收、也不用每个学生分配一个老师一直等着，直接让做完作业的学生通知老师即可，这期间老师可以做其他事情。</p>
<h6>2）事件驱动<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7435007932700459</span></h6>
<p>事件驱动是一种编程范式，指整个系统间的各个组件通过发送和接收事件进行通信和协作，从而实现异步非阻塞 IO。</p>
<p>举个例子，前端和后端协作开发，可以先分别开发、各干各的，不用等待对方开发完成再开发。等后端写完了接口，告诉前端 “我写好了”（相当于发送了一个事件），前端接收到这个信息后，就可以对接后端了。</p>
<p>不过以上只是一个便于大家理解的例子，实际的事件驱动实现中，一般会有事件总线（Event Bus）的概念，相当于一个中间人，负责接受所有的事件，并分发给不同的事件处理者。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6727671509419946</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/1e8e164b-34ac-4c01-b9fe-9a5551c7ff0a.png" alt="image.png" class="medium-zoom-image"></p>
<blockquote>
<p>学过消息队列的同学，应该会更好理解事件驱动，两者都能实现异步通信和应用解耦。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05673183356990941</span></blockquote>
<h6>3）事件循环<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8333458266751723</span></h6>
<p>事件循环是实现事件驱动的核心操作，也是实现异步、非阻塞编程的方法。</p>
<p>在一个事件循环中，程序会不断地检查事件队列，如果有新事件到达，就会触发相应处理程序的回调函数来执行。允许程序在等待 I/O 操作完成的同时继续执行其他任务，而不会阻塞整个进程。</p>
<p>举个生活中的例子，老师要收整个班级的作业，可以找一位课代表，课代表 <strong>每小时</strong> 循环检查所有同学交的作业情况，如果发现有新的提交，就通知老师批改。这样老师就不用一直等着学生完成作业（I / O 操作），不去做其他的事情。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5207877599203363</span></p>
<blockquote>
<p>Node.js 就使用了事件循环机制，实现了非阻塞 IO 和事件驱动。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18599432688100515</span></blockquote>
<h6 data-id="heading-59">4）反应式编程</h6>
<p>反应式编程是一种编程范式，常用于异步的数据流和事件处理，通过声明的方式来定义处理规则。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2565014266388983</span></p>
<p>它最核心的作用还是实现了异步处理（类似 CompletableFuture），只不过通过一系列 API 的支持，便于我们更轻松地处理异步数据。</p>
<p>举个例子，传统的同步编程方式：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.35405756567412205</span></span> {
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.07592118516041313</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.26320994397525976</span></span> {
        <span class="hljs-comment">// 同步查询数据库</span>
        <span class="hljs-keyword">return</span> userRepository.findById(userId);
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2750118056828077</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.23622063654967818</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.24644165444042265</span></pre>
<p>上述代码中，<code>getUserById</code> 方法是同步的，当执行数据库查询时，线程会被阻塞，等待查询结果返回。如果系统中有大量的并发请求，这种同步阻塞的方式可能会导致性能瓶颈，因为每个请求都需要等待数据库查询完成。</p>
<p>如果使用反应式编程，示例代码如下：</p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4913022777369733</span></span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">public</span> Mono&lt;User&gt; <span class="hljs-title function_">getUserById<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7078767534360488</span></span><span class="hljs-params">(<span class="hljs-type">long</span> userId)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6242322135938112</span></span> {
        <span class="hljs-comment">// 使用反应式编程的 Mono 封装异步查询</span>
        <span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.45328383098372504</span></span> userRepository.findById(userId);
    }
}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3134633849719417</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.10279338348461087</span><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8130245487660914</span></pre>
<p>上述代码中，<code>getUserById</code> 方法返回的是 Reactor 的 Mono 类型，表示异步计算的结果，我们可以再对这个 Mono 类型定义各种复杂的处理操作。其中调用的 <code>userRepository.findById</code> 是一个异步的数据库查询操作，不会阻塞当前线程。</p>
<hr>
<p>Vert.x 正是使用了以上几个概念，才能够同时处理更多的并发请求。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.40131029606731805</span></p>
<p>但如果将我们的接口使用 Vert.x 重构，真的会更快么？</p>
<p><strong>所有的性能优化都要以实际测试为准！</strong></p>
<h4>4、Vert.x 改造请求<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.28262829723130767</span></h4>
<p>1）在 <code>vertx</code> 包下创建一个新的 Verticle，名称为 <code>MainVericle.java</code>。</p>
<p>需要自主获取请求信息，判断请求的路径和方法、获取请求数据，并执行对应的逻辑。</p>
<p>示例代码如下：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6885451817115475</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes">requestHandler(req -&gt; {
    <span class="hljs-type">HttpMethod</span> <span class="hljs-variable">httpMethod</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.744273104929071</span></span> req.method();
    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.35539969175662667</span></span> req.path();
    <span class="hljs-comment">// 分页获取生成器</span>
    <span class="hljs-keyword">if</span> (HttpMethod.POST.equals(httpMethod) &amp;&amp; <span class="hljs-string">"/generator/page"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5996436467132402</span></span>.equals(path)) {
        <span class="hljs-comment">// 设置请求体处理器</span>
        req.handler(buffer -&gt; {
            <span class="hljs-comment">// 获取请求体中的 JSON 数据</span>
            <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.57486430570754</span></span> <span class="hljs-variable">requestBody</span> <span class="hljs-operator">=</span> buffer.toString();

            <span class="hljs-comment">// 处理业务逻辑<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8560069583094256</span></span>
            response.end(<span class="hljs-string">""</span>);
        });
    }
})
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.33982221629338505</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7267678091650707</span></pre>
<p>2）将之前查询接口的逻辑搬到 Verticle 中。为了方便测试，仅编写读取缓存的逻辑。</p>
<p>MainVerticle 完整代码如下，通过构造函数接受 cacheManager 对象：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6297504795920537</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">package</span> com.yupi.web.vertx;

<span class="hljs-keyword">import</span> cn.hutool.core.lang.TypeReference;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5563606531415561</span></span> cn.hutool.json.JSONUtil;
<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;
<span class="hljs-keyword">import</span> com.yupi.web.common.ResultUtils;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.742083838945153</span></span> com.yupi.web.controller.GeneratorController;
<span class="hljs-keyword">import</span> com.yupi.web.manager.CacheManager;
<span class="hljs-keyword">import</span> com.yupi.web.model.dto.generator.GeneratorQueryRequest;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4945736290117926</span></span> com.yupi.web.model.vo.GeneratorVO;
<span class="hljs-keyword">import</span> io.vertx.core.AbstractVerticle;
<span class="hljs-keyword">import</span> io.vertx.core.http.HttpMethod;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2931712308935699</span></span> io.vertx.core.http.HttpServerResponse;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainVerticle<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.1172385418656674</span></span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractVerticle</span> {

    <span class="hljs-keyword">private<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.13913315095133183</span></span> CacheManager cacheManager;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MainVerticle</span><span class="hljs-params">(CacheManager cacheManager)<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18832863013666934</span></span> {
        <span class="hljs-built_in">this</span>.cacheManager = cacheManager;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.04374314500226073</span></span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05307283558566489</span></span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// Create the HTTP server</span>
        vertx.createHttpServer()
                <span class="hljs-comment">// Handle every request using the router<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.288561091663986</span></span>
                .requestHandler(req -&gt; {
                    <span class="hljs-type">HttpMethod</span> <span class="hljs-variable">httpMethod</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6212418271710998</span></span> req.method();
                    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5985592975881833</span></span> req.path();
                    <span class="hljs-comment">// 分页获取生成器</span>
                    <span class="hljs-keyword">if</span> (HttpMethod.POST.equals(httpMethod) &amp;&amp; <span class="hljs-string">"/generator/page"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8156989621406605</span></span>.equals(path)) {
                        <span class="hljs-comment">// 设置请求体处理器</span>
                        req.handler(buffer -&gt; {
                            <span class="hljs-comment">// 获取请求体中的 JSON 数据</span>
                            <span class="hljs-type">String<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.54565867891306</span></span> <span class="hljs-variable">requestBody</span> <span class="hljs-operator">=</span> buffer.toString();
                            <span class="hljs-type">GeneratorQueryRequest<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.39596536673387384</span></span> <span class="hljs-variable">generatorQueryRequest</span> <span class="hljs-operator">=</span> JSONUtil.toBean(requestBody, GeneratorQueryRequest.class);

                            <span class="hljs-comment">// 处理 JSON 数据<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.33400746966846295</span></span>
                            <span class="hljs-comment">// 在实际应用中，这里可以解析 JSON、执行业务逻辑等</span>
                            <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5722422165018783</span></span> <span class="hljs-operator">=</span> GeneratorController.getPageCacheKey(generatorQueryRequest);

                            <span class="hljs-comment">// 设置响应头</span>
                            <span class="hljs-type">HttpServerResponse<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7045432867660468</span></span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> req.response();
                            response.putHeader(<span class="hljs-string">"content-type"<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.06723179997889117</span></span>, <span class="hljs-string">"application/json"</span>);

                            <span class="hljs-comment">// 本地缓存</span>
                            <span class="hljs-type">Object<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9360713114890917</span></span> <span class="hljs-variable">cacheValue</span> <span class="hljs-operator">=</span> cacheManager.get(cacheKey);
                            <span class="hljs-keyword">if<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7093388191478958</span></span> (cacheValue != <span class="hljs-literal">null</span>) {
                                <span class="hljs-comment">// 返回 JSON 响应</span>
                                response.end(JSONUtil.toJsonStr(ResultUtils.success((Page&lt;GeneratorVO&gt;) cacheValue)));
                                <span class="hljs-keyword">return<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.23240701914312423</span></span>;
                            }

                            response.end(<span class="hljs-string">""</span>);
                        });
                    }
                })
                <span class="hljs-comment">// Start listening</span>
                .listen(<span class="hljs-number">8888<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8072032035791328</span></span>)
                <span class="hljs-comment">// Print the port</span>
                .onSuccess(server -&gt;
                        System.out.println(
                                <span class="hljs-string">"HTTP server started on port "</span> + server.actualPort()
                        )
                );
    }

}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.3671964715932947</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7399650548949441</span></pre>
<p>3）创建 VertxManager Bean，用于创建 Vertx 容器、并给它注入 cacheManager 依赖。</p>
<p>代码如下：<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9425156137787565</span></p>
<pre style="position: relative; padding-top: 3em; overflow: auto;"><div class="code-block-extension-header" style="position: absolute; top: 0; left: 0; width: 100%; height:28px; font-size:1em; background-color: rgb(248, 248, 248); box-shadow: 0px 4px 5px -6px #888888; display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em;"><div class="code-block-extension-headerLeft" style="filter: invert(0.5); opacity: 0.6;"><span class="code-block-extension-lang">java</span></div><div class="code-block-extension-headerRight" style="cursor: pointer;"><div class="code-block-extension-copyCodeBtn" style="filter: invert(0.5); opacity: 0.6;">复制代码</div></div></div><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">package</span> com.yupi.web.vertx;

<span class="hljs-keyword">import</span> com.yupi.web.manager.CacheManager;
<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7464767933024821</span></span> io.vertx.core.Verticle;
<span class="hljs-keyword">import</span> io.vertx.core.Vertx;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-keyword">import<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.873559216588222</span></span> javax.annotation.PostConstruct;
<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.012713598075687393</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VertxManager</span> {

    <span class="hljs-meta">@Resource<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.2588953518538242</span></span>
    <span class="hljs-keyword">private</span> CacheManager cacheManager;

    <span class="hljs-meta">@PostConstruct</span>
    <span class="hljs-keyword">public<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.11593358063367853</span></span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.4126264109707456</span></span> {
        <span class="hljs-type">Vertx</span> <span class="hljs-variable">vertx</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.9021393745180284</span></span> Vertx.vertx();
        <span class="hljs-type">Verticle</span> <span class="hljs-variable">myVerticle</span> <span class="hljs-operator">=<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5150052367323266</span></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainVerticle</span>(cacheManager);
        vertx.deployVerticle(myVerticle);
    }

}
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7093257295983799</span></code><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.22542572317244436</span></pre>
<h4 data-id="heading-61">5、测试</h4>
<p>创建新的压力测试，复用之前的线程组设置，请求地址修改为 vertx 的接口地址 <code>/generator/page</code>，传入同样的参数。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.7870794145196869</span></p>
<p>如下图：</p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/2751cc56-ed09-47d1-88bc-e46ea825c160.png" alt="image.png" class="medium-zoom-image"></p>
<p>测试结果如下图，qps 反而更低了？！<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.18549494717051762</span></p>
<p><img src="https://pic.code-nav.cn/post_picture/1610518142000300034/0ecf227c-e228-4bf1-b13a-b410c5c42387.png" alt="image.png" class="medium-zoom-image"></p>
<p>为什么用了 Vert.x 后反而更慢了？所谓的性能更高是个骗局么？</p>
<p>其实这是很正常的，因为每个技术都有适合自己的应用场景。<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.05258201596167056</span></p>
<p>Vert.x 是一个基于事件驱动、非阻塞、异步的框架，它的设计目标是处理大量并发连接。与之相反，Spring Boot 内置的 Tomcat 是同步阻塞模型。在某些场景下（比如传统 CRUD 应用、或者 IO 操作较少），同步阻塞模型可能会更适用，因为都需要等待数据处理完成后再返回响应，反而减少了线程调度的成本。Vert.x 更适合于实时应用，例如聊天应用、实时通信等，或者 IO 密集型的任务。</p>
<blockquote>
<p>扩展：尝试编写一个 IO 操作密集的接口（比如文件下载），并通过 Vert.x 框架重构接口，验证优化效果。</p>
<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.6574551510938209</span></blockquote>
<h2>最后<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.5422930940604982</span></h2>
<p>以上就是本期教程，本节教程中我们学到了性能优化的思路，并且实践了 8 种性能优化的方法，希望大家能够灵活运用这些知识，通过测试、分析、实践的闭环持续优化自己的项目。</p>
<h2 data-id="heading-63">本期作业</h2>
<p>1）掌握常用的性能优化思路<span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.8074808028365934</span></p>
<p>2）实践查询性能优化，并且得到 qps 的提升结果。</p>
<p>3）自己编写代码实现本节项目，并且在自己的代码仓库完成一次提交。</p><span class="yuyuan-water-mark" style="color: transparent; position: absolute; width: 0px; height: 0px; z-index: -1;">1638649696178216961_0.12249221884079597</span></div></div></div><div style="margin-bottom: 16px;"></div><div style="margin-bottom: 16px;"></div><div id="toggleArea" class="ant-row ant-row-no-wrap ant-row-space-between" style="margin-left: -10px; margin-right: -10px; margin-top: 40px; row-gap: 20px;"><div class="ant-col" style="padding-left: 10px; padding-right: 10px;"><div>上一节</div><a href="/course/1790980795074654209/section/1790996773246382081"><div class="ant-space ant-space-horizontal ant-space-align-center" style="gap: 8px;"><div class="ant-space-item" style=""><span role="img" aria-label="double-left" class="anticon anticon-double-left" style="font-size: 10px;"><svg viewBox="64 64 896 896" focusable="false" data-icon="double-left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z"></path></svg></span></div><div class="ant-space-item"><div class="text-ellipsis">12. 在线制作</div></div></div></a></div><div class="ant-col" style="padding-left: 10px; padding-right: 10px;"><div>下一节</div><a href="/course/1790980795074654209/section/1790996857287651330"><div class="ant-space ant-space-horizontal ant-space-align-center" style="gap: 8px;"><div class="ant-space-item" style=""><div class="text-ellipsis">14. 存储优化</div></div><div class="ant-space-item"><span role="img" aria-label="double-right" class="anticon anticon-double-right" style="font-size: 10px;"><svg viewBox="64 64 896 896" focusable="false" data-icon="double-right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z"></path></svg></span></div></div></a></div></div></div>